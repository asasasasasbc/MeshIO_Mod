AssemblyInfo.cs-------------
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// In SDK-style projects such as this one, several assembly attributes that were historically
// defined in this file are now automatically added during build and populated with
// values defined in project properties. For details of which attributes are included
// and how to customise this process see: https://aka.ms/assembly-info-properties


// Setting ComVisible to false makes the types in this assembly not visible to COM
// components.  If you need to access a type in this assembly from COM, set the ComVisible
// attribute to true on that type.

[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM.

[assembly: Guid("3aad1ea4-d939-42e8-8b5b-a990665e14d7")]

[assembly: InternalsVisibleTo("MeshIO.FBX.Tests")]

DeflateWithChecksum.cs-------------
using System.IO;
using System.IO.Compression;

namespace MeshIO.FBX
{
	/// <summary>
	/// A wrapper for DeflateStream that calculates the Adler32 checksum of the payload
	/// </summary>
	public class DeflateWithChecksum : DeflateStream
	{
		private const int modAdler = 65521;
		private uint checksumA;
		private uint checksumB;

		/// <summary>
		/// Gets the Adler32 checksum at the current point in the stream
		/// </summary>
		public int Checksum
		{
			get
			{
				checksumA %= modAdler;
				checksumB %= modAdler;
				return (int)((checksumB << 16) | checksumA);
			}
		}

		/// <inheritdoc />
		public DeflateWithChecksum(Stream stream, CompressionMode mode) : base(stream, mode)
		{
			ResetChecksum();
		}

		/// <inheritdoc />
		public DeflateWithChecksum(Stream stream, CompressionMode mode, bool leaveOpen) : base(stream, mode, leaveOpen)
		{
			ResetChecksum();
		}

		// Efficiently extends the checksum with the given buffer
		void CalcChecksum(byte[] array, int offset, int count)
		{
			checksumA %= modAdler;
			checksumB %= modAdler;
			for (int i = offset, c = 0; i < (offset + count); i++, c++)
			{
				checksumA += array[i];
				checksumB += checksumA;
				if (c > 4000) // This is about how many iterations it takes for B to reach IntMax
				{
					checksumA %= modAdler;
					checksumB %= modAdler;
					c = 0;
				}
			}
		}

		/// <inheritdoc />
		public override void Write(byte[] array, int offset, int count)
		{
			base.Write(array, offset, count);
			CalcChecksum(array, offset, count);
		}

		/// <inheritdoc />
		public override int Read(byte[] array, int offset, int count)
		{
			var ret = base.Read(array, offset, count);
			CalcChecksum(array, offset, count);
			return ret;
		}

		/// <summary>
		/// Initializes the checksum values
		/// </summary>
		public void ResetChecksum()
		{
			checksumA = 1;
			checksumB = 0;
		}
	}
}


ErrorLevel.cs-------------
namespace MeshIO.FBX
{
	/// <summary>
	/// Indicates when a reader should throw errors
	/// </summary>
	public enum ErrorLevel
	{
		/// <summary>
		/// Ignores inconsistencies unless the parser can no longer continue
		/// </summary>
		Permissive = 0,

		/// <summary>
		/// Checks data integrity, such as checksums and end points
		/// </summary>
		Checked = 1,

		/// <summary>
		/// Checks everything, including magic bytes
		/// </summary>
		Strict = 2,
	}
}


FbxBinary.cs-------------
using MeshIO.FBX.Exceptions;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace MeshIO.FBX
{
	/// <summary>
	/// Base class for binary stream wrappers
	/// </summary>
	internal abstract class FbxBinary : IDisposable
	{
		/// <summary>
		/// The size of the footer code
		/// </summary>
		protected const int footerCodeSize = 16;

		/// <summary>
		/// The namespace separator in the binary format (remember to reverse the identifiers)
		/// </summary>
		protected const string binarySeparator = "\0\x1";

		/// <summary>
		/// The namespace separator in the ASCII format and in object data
		/// </summary>
		protected const string asciiSeparator = "::";

		const string timePath1 = "FBXHeaderExtension";
		const string timePath2 = "CreationTimeStamp";
		static readonly Stack<string> timePath = new Stack<string>(new[] { timePath1, timePath2 });

		// Header string, found at the top of all compliant files
		private static readonly byte[] headerString = Encoding.ASCII.GetBytes("Kaydara FBX Binary  \0\x1a\0");

		// This data was entirely calculated by me, honest. Turns out it works, fancy that!
		private static readonly byte[] sourceId = { 0x58, 0xAB, 0xA9, 0xF0, 0x6C, 0xA2, 0xD8, 0x3F, 0x4D, 0x47, 0x49, 0xA3, 0xB4, 0xB2, 0xE7, 0x3D };
		private static readonly byte[] key = { 0xE2, 0x4F, 0x7B, 0x5F, 0xCD, 0xE4, 0xC8, 0x6D, 0xDB, 0xD8, 0xFB, 0xD7, 0x40, 0x58, 0xC6, 0x78 };
		// This wasn't - it just appears at the end of every compliant file
		private static readonly byte[] extension = { 0xF8, 0x5A, 0x8C, 0x6A, 0xDE, 0xF5, 0xD9, 0x7E, 0xEC, 0xE9, 0x0C, 0xE3, 0x75, 0x8F, 0x29, 0x0B };

		// Number of null bytes between the footer code and the version
		private const int footerZeroes1 = 20;
		// Number of null bytes between the footer version and extension code
		private const int footerZeroes2 = 120;

		/// <summary>
		/// Checks if the first part of 'data' matches 'original'
		/// </summary>
		/// <param name="data"></param>
		/// <param name="original"></param>
		/// <returns><c>true</c> if it does, otherwise <c>false</c></returns>
		protected static bool CheckEqual(byte[] data, byte[] original)
		{
			for (int i = 0; i < original.Length; i++)
				if (data[i] != original[i])
					return false;
			return true;
		}

		/// <summary>
		/// Writes the FBX header string
		/// </summary>
		/// <param name="stream"></param>
		protected static void WriteHeader(Stream stream)
		{
			stream.Write(headerString, 0, headerString.Length);
		}

		/// <summary>
		/// Reads the FBX header string
		/// </summary>
		/// <param name="stream"></param>
		/// <returns><c>true</c> if it's compliant</returns>
		public static bool ReadHeader(Stream stream)
		{
			var buf = new byte[headerString.Length];
			stream.Read(buf, 0, buf.Length);
			return CheckEqual(buf, headerString);
		}

		public abstract void Dispose();

		// Turns out this is the algorithm they use to generate the footer. Who knew!
		static void Encrypt(byte[] a, byte[] b)
		{
			byte c = 64;
			for (int i = 0; i < footerCodeSize; i++)
			{
				a[i] = (byte)(a[i] ^ (byte)(c ^ b[i]));
				c = a[i];
			}
		}

		// Gets a single timestamp component
		static int GetTimestampVar(FbxNode timestamp, string element)
		{
			var elementNode = timestamp[element];
			if (elementNode != null && elementNode.Properties.Count > 0)
			{
				var prop = elementNode.Properties[0];
				if (prop is int || prop is long)
					return (int)prop;
			}
			throw new FbxException(timePath, -1, "Timestamp has no " + element);
		}

		/// <summary>
		/// Generates the unique footer code based on the document's timestamp
		/// </summary>
		/// <param name="document"></param>
		/// <returns>A 16-byte code</returns>
		protected static byte[] GenerateFooterCode(FbxNodeCollection document)
		{
			var timestamp = document.GetRelative(timePath1 + "/" + timePath2);
			if (timestamp == null)
				throw new FbxException(timePath, -1, "No creation timestamp");
			try
			{
				return GenerateFooterCode(
					GetTimestampVar(timestamp, "Year"),
					GetTimestampVar(timestamp, "Month"),
					GetTimestampVar(timestamp, "Day"),
					GetTimestampVar(timestamp, "Hour"),
					GetTimestampVar(timestamp, "Minute"),
					GetTimestampVar(timestamp, "Second"),
					GetTimestampVar(timestamp, "Millisecond")
					);
			}
			catch (ArgumentOutOfRangeException)
			{
				throw new FbxException(timePath, -1, "Invalid timestamp");
			}
		}

		/// <summary>
		/// Generates a unique footer code based on a timestamp
		/// </summary>
		/// <param name="year"></param>
		/// <param name="month"></param>
		/// <param name="day"></param>
		/// <param name="hour"></param>
		/// <param name="minute"></param>
		/// <param name="second"></param>
		/// <param name="millisecond"></param>
		/// <returns>A 16-byte code</returns>
		protected static byte[] GenerateFooterCode(
			int year, int month, int day,
			int hour, int minute, int second, int millisecond)
		{
			if (year < 0 || year > 9999)
				throw new ArgumentOutOfRangeException(nameof(year));
			if (month < 0 || month > 12)
				throw new ArgumentOutOfRangeException(nameof(month));
			if (day < 0 || day > 31)
				throw new ArgumentOutOfRangeException(nameof(day));
			if (hour < 0 || hour >= 24)
				throw new ArgumentOutOfRangeException(nameof(hour));
			if (minute < 0 || minute >= 60)
				throw new ArgumentOutOfRangeException(nameof(minute));
			if (second < 0 || second >= 60)
				throw new ArgumentOutOfRangeException(nameof(second));
			if (millisecond < 0 || millisecond >= 1000)
				throw new ArgumentOutOfRangeException(nameof(millisecond));

			var str = (byte[])sourceId.Clone();
			var mangledTime = $"{second:00}{month:00}{hour:00}{day:00}{(millisecond / 10):00}{year:0000}{minute:00}";
			var mangledBytes = Encoding.ASCII.GetBytes(mangledTime);
			Encrypt(str, mangledBytes);
			Encrypt(str, key);
			Encrypt(str, mangledBytes);
			return str;
		}

		/// <summary>
		/// Writes the FBX footer extension (NB - not the unique footer code)
		/// </summary>
		/// <param name="stream"></param>
		/// <param name="version"></param>
		protected void WriteFooter(BinaryWriter stream, int version)
		{
			var zeroes = new byte[Math.Max(footerZeroes1, footerZeroes2)];
			stream.Write(zeroes, 0, footerZeroes1);
			stream.Write(version);
			stream.Write(zeroes, 0, footerZeroes2);
			stream.Write(extension, 0, extension.Length);
		}

		protected static bool AllZero(byte[] array)
		{
			foreach (var b in array)
				if (b != 0)
					return false;
			return true;
		}

		/// <summary>
		/// Reads and checks the FBX footer extension (NB - not the unique footer code)
		/// </summary>
		/// <param name="stream"></param>
		/// <param name="version"></param>
		/// <returns><c>true</c> if it's compliant</returns>
		protected bool CheckFooter(BinaryReader stream, FbxVersion version)
		{
			var buffer = new byte[Math.Max(footerZeroes1, footerZeroes2)];
			stream.Read(buffer, 0, footerZeroes1);
			bool correct = AllZero(buffer);
			var readVersion = stream.ReadInt32();
			correct &= (readVersion == (int)version);
			stream.Read(buffer, 0, footerZeroes2);
			correct &= AllZero(buffer);
			stream.Read(buffer, 0, extension.Length);
			correct &= CheckEqual(buffer, extension);
			return correct;
		}
	}
}


FbxFileToken.cs-------------
using System;

namespace MeshIO.FBX
{
	public class FbxFileToken
	{
		public const string Version = "Version";
		public const string Count = "Count";

		public const string FBXHeaderExtension = "FBXHeaderExtension";
		public const string FBXHeaderVersion = "FBXHeaderVersion";
		public const string FBXVersion = "FBXVersion";
		public const string EncryptionType = "EncryptionType";
		public const string CreationTimeStamp = "CreationTimeStamp";
		public const string Creator = "Creator";

		public const string GlobalSettings = "GlobalSettings";

		public const string Documents = "Documents";
		public const string Document = "Document";

		public const string References = "References";

		public const string Definitions = "Definitions";
		public const string ObjectType = "ObjectType";

		public const string Objects = "Objects";

		public const string Connections = "Connections";

		public const string Scene = "Scene";
		public const string RootNode = "RootNode";

		public const string Mesh = "Mesh";

		public const string Model = "Model";
		public const string Shading = "Shading";
		public const string CullingOff = "CullingOff";

		public const string Geometry = "Geometry";
		public const string Material = "Material";

		public static string GetPropertiesName(FbxVersion version)
		{
			switch (version)
			{
				case FbxVersion.v2000:
				case FbxVersion.v2001:
				case FbxVersion.v3000:
				case FbxVersion.v3001:
				case FbxVersion.v4000:
				case FbxVersion.v4001:
				case FbxVersion.v4050:
				case FbxVersion.v5000:
				case FbxVersion.v5800:
					throw new NotSupportedException();
				case FbxVersion.v6000:
				case FbxVersion.v6100:
					return "Properties60";
				case FbxVersion.v7000:
				case FbxVersion.v7100:
				case FbxVersion.v7200:
				case FbxVersion.v7300:
				case FbxVersion.v7400:
				case FbxVersion.v7500:
				case FbxVersion.v7600:
				case FbxVersion.v7700:
					return "Properties70";
				default:
					throw new NotSupportedException();
			}
		}
	}
}


FbxGlobalSettings.cs-------------
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace MeshIO.FBX
{
	/// <summary>
	/// Global settings to be setup in the fbx file
	/// </summary>
	public class FbxGlobalSettings
	{
		public int Version { get; }

		public int UpAxis
		{
			get
			{
				return getPropertyValue<int>();
			}
			set
			{
				setPropertyValue(value);
			}
		}

		public IEnumerable<FbxProperty> Properties { get { return this._properties.Values; } }

		private Dictionary<string, FbxProperty> _properties { get; } = new();

		public FbxGlobalSettings(FbxVersion version)
		{
			switch (version)
			{
				case FbxVersion.v2000:
				case FbxVersion.v2001:
				case FbxVersion.v3000:
				case FbxVersion.v3001:
				case FbxVersion.v4000:
				case FbxVersion.v4001:
				case FbxVersion.v4050:
				case FbxVersion.v5000:
				case FbxVersion.v5800:
				case FbxVersion.v6000:
				case FbxVersion.v6100:
				case FbxVersion.v7000:
				case FbxVersion.v7100:
				case FbxVersion.v7200:
				case FbxVersion.v7300:
				case FbxVersion.v7400:
				case FbxVersion.v7500:
				case FbxVersion.v7600:
				case FbxVersion.v7700:
					Version = 1000;
					break;
				default:
					break;
			}

			this.add(new("UpAxis", "int", "Integer", PropertyFlags.None, 1));
			this.add(new("UpAxisSign", "int", "Integer", PropertyFlags.None, 1));
			this.add(new("FrontAxis", "int", "Integer", PropertyFlags.None, 2));
			this.add(new("FrontAxisSign", "int", "Integer", PropertyFlags.None, 1));
			this.add(new("CoordAxis", "int", "Integer", PropertyFlags.None, 0));
			this.add(new("CoordAxisSign", "int", "Integer", PropertyFlags.None, 1));
			this.add(new("OriginalUpAxis", "int", "Integer", PropertyFlags.None, 2));
			this.add(new("OriginalUpAxisSign", "int", "Integer", PropertyFlags.None, 1));
			this.add(new("UnitScaleFactor", "double", "Number", PropertyFlags.None, 1.0d));
			this.add(new("OriginalUnitScaleFactor", "double", "Number", PropertyFlags.None, 1.0d));
			this.add(new("AmbientColor", "ColorRGB", "Color", PropertyFlags.None, new Color()));
			this.add(new("DefaultCamera", "KString", string.Empty, PropertyFlags.None, "Producer Perspective"));
			this.add(new("TimeMode", "enum", string.Empty, PropertyFlags.None, 6));
			this.add(new("TimeProtocol", "enum", string.Empty, PropertyFlags.None, 2));
			this.add(new("SnapOnFrameMode", "enum", string.Empty, PropertyFlags.None, 0));
			this.add(new("TimeSpanStart", "KTime", "Time", PropertyFlags.None, 0));
			this.add(new("TimeSpanStop", "KTime", "Time", PropertyFlags.None, 153953860000));
			this.add(new("CustomFrameRate", "double", "Number", PropertyFlags.None, -1.0d));
			this.add(new("TimeMarker", "Compound", string.Empty, PropertyFlags.None, string.Empty));
			this.add(new("CurrentTimeMarker", "int", "Integer", PropertyFlags.None, -1));
		}

		private void add(FbxProperty property)
		{
			this._properties.Add(property.Name, property);
		}

		private T getPropertyValue<T>([CallerMemberName] string name = null)
		{
			return (T)_properties[name].Value;
		}

		private void setPropertyValue(object value, [CallerMemberName] string name = null)
		{
			_properties[name].Value = value;
		}
	}
}


FbxNode.cs-------------
using System;
using System.Collections.Generic;
using System.Linq;

namespace MeshIO.FBX
{
	/// <summary>
	/// Represents a node in an FBX file
	/// </summary>
	public class FbxNode : FbxNodeCollection
	{
		/// <summary>
		/// The node name, which is often a class type
		/// </summary>
		/// <remarks>
		/// The name must be smaller than 256 characters to be written to a binary stream
		/// </remarks>
		public string Name { get; set; }

		/// <summary>
		/// Whether the node is empty of data
		/// </summary>
		public bool IsEmpty => string.IsNullOrEmpty(Name) && Properties.Count == 0 && Nodes.Count == 0;

		/// <summary>
		/// The list of properties associated with the node
		/// </summary>
		/// <remarks>
		/// Supported types are primitives (apart from byte and char),arrays of primitives, and strings
		/// </remarks>
		public List<object> Properties { get; } = new List<object>();

		/// <summary>
		/// The first property element
		/// </summary>
		public object Value
		{
			get { return Properties.Count < 1 ? null : Properties[0]; }
			set
			{
				if (Properties.Count < 1)
					Properties.Add(value);
				else
					Properties[0] = value;
			}
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public FbxNode() : base() { }

		/// <summary>
		/// 
		/// </summary>
		/// <param name="name"></param>
		public FbxNode(string name) : base()
		{
			Name = name;
		}

		public FbxNode(string name, object value) : this(name)
		{
			Value = value;
		}

		public FbxNode(string name, params object[] properties) : this(name)
		{
			Properties = new List<object>(properties);
		}

		public bool TryGetProperty<T>(int index, out T value)
		{
			var v = this.Properties.ElementAtOrDefault(index);
			if (v is T t)
			{
				value = t;
				return true;
			}
			else
			{
				value = default;
				return false;
			}
		}

		public T GetProperty<T>(int index)
		{
			object value = this.Properties.ElementAtOrDefault(index);
			return (T)Convert.ChangeType(value, typeof(T));
		}

		public override string ToString()
		{
			return $"{Name}:{Value}";
		}
	}
}


FbxNodeCollection.cs-------------
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace MeshIO.FBX
{
	/// <summary>
	/// Base class for nodes and documents
	/// </summary>
	public abstract class FbxNodeCollection : IEnumerable<FbxNode>
	{
		/// <summary>
		/// The list of child/nested nodes
		/// </summary>
		/// <remarks>
		/// A list with one or more null elements is treated differently than an empty list,
		/// and represented differently in all FBX output files.
		/// </remarks>
		public List<FbxNode> Nodes { get; } = new List<FbxNode>();

		/// <summary>
		/// Gets a named child node
		/// </summary>
		/// <param name="name"></param>
		/// <returns>The child node, or null</returns>
		public FbxNode this[string name] { get { return this.Nodes.Find(n => n != null && n.Name == name); } }

		/// <summary>
		/// Add a note into the collection
		/// </summary>
		/// <param name="name"></param>
		/// <param name="args"></param>
		/// <returns>the added node</returns>
		public FbxNode Add(string name, params object[] args)
		{
			FbxNode n = new FbxNode(name, args);
			this.Nodes.Add(n);
			return n;
		}

		/// <summary>
		/// Gets a child node, using a '/' separated path
		/// </summary>
		/// <param name="path"></param>
		/// <returns>The child node, or null</returns>
		public FbxNode GetRelative(string path)
		{
			var tokens = path.Split('/');
			FbxNodeCollection current = this as FbxNodeCollection;
			foreach (string t in tokens)
			{
				if (t == "")
					continue;
				current = current[t];
				if (current == null)
					break;
			}
			return current as FbxNode;
		}

		/// <summary>
		/// Checks if the name of the node is repeated
		/// </summary>
		/// <param name="name"></param>
		/// <returns></returns>
		public bool MultipleNodes(string name)
		{
			return this.Nodes.Where(n => n.Name == name).Count() > 1;
		}

		public IEnumerable<FbxNode> GetNodes(string name)
		{
			return this.Nodes.Where(n => n.Name == name);
		}

		/// <summary>
		/// Gets the first named node if exists
		/// </summary>
		/// <param name="name"></param>
		/// <param name="node"></param>
		/// <returns></returns>
		public bool TryGetNode(string name, out FbxNode node)
		{
			node = this[name];
			return node != null;
		}

		/// <inheritdoc/>
		public IEnumerator<FbxNode> GetEnumerator()
		{
			return Nodes.GetEnumerator();
		}

		/// <inheritdoc/>
		IEnumerator IEnumerable.GetEnumerator()
		{
			return Nodes.GetEnumerator();
		}
	}
}


FbxProperty.cs-------------
using CSMath;
using System;
using System.Collections.Generic;
using System.Linq;

namespace MeshIO.FBX
{
	public class FbxProperty : Property
	{
		public static class Geometry
		{
			public const string Color = "Color";
			public const string BBoxMin = "BBoxMin";
			public const string BBoxMax = "BBoxMax";
			public const string PrimaryVisibility = "Primary Visibility";
			public const string CastsShadows = "Casts Shadows";

			//public static FbxProperty<bool> CreatePrimaryVisibility() => new FbxProperty<bool>(PrimaryVisibility, true);
		}

		/// <summary>
		/// Fbx equivalent type name
		/// </summary>
		public string FbxType { get; }

		/// <summary>
		/// Fbx label
		/// </summary>
		public string Label { get; }

		public FbxProperty(string name, PropertyFlags flags, object value) : this(name, string.Empty, string.Empty, flags, value)
		{
			GetFbxValue(value, out string fbxtype, out string label);
			this.FbxType = fbxtype;
			this.Label = label;
		}

		public FbxProperty(string name, string fbxtype, string label, PropertyFlags flags, object value) : base(name)
		{
			this.FbxType = fbxtype;
			this.Label = label;
			this.Flags = flags;

			if (value is byte b)
			{
				this.Value = (int)b;
			}
			else
			{
				this.Value = value;
			}
		}

		public FbxProperty(FbxProperty property, object value) : this(property.Name, property.FbxType, property.Label, property.Flags, value)
		{
		}

		/// <summary>
		/// Create a <see cref="FbxProperty"/> based on a <see cref="Property"/>
		/// </summary>
		/// <param name="property"></param>
		/// <returns></returns>
		public static FbxProperty CreateFrom(Property property)
		{
			return new FbxProperty(property.Name, property.Flags, property.Value);
		}

		public Property ToProperty()
		{
			Property property = null;

			object value = this.Value;
			List<object> arr = null;
			if (value is IEnumerable<object> en)
			{
				arr = new List<object>(en);
			}

			switch (FbxType)
			{
				case "Color":
				case "ColorRGB":
					byte r = (byte)(Convert.ToDouble(arr[0]) * 255);
					byte g = (byte)(Convert.ToDouble(arr[1]) * 255);
					byte b = (byte)(Convert.ToDouble(arr[2]) * 255);
					property = new Property<Color>(this.Name, Flags, new Color(r, g, b));
					break;
				case "ColorAndAlpha":
					r = (byte)(Convert.ToDouble(arr[0]) * 255);
					g = (byte)(Convert.ToDouble(arr[1]) * 255);
					b = (byte)(Convert.ToDouble(arr[2]) * 255);
					byte a = (byte)(Convert.ToDouble(arr[3]) * 255);
					property = new Property<Color>(this.Name, Flags, new Color(r, g, b, a));
					break;
				case "Visibility":
				case "Bool":
				case "bool":
					property = new Property<bool>(this.Name, Flags, Convert.ToInt32(value) != 0);
					break;
				case "Vector":
				case "Vector3":
				case "Vector3D":
				case "Lcl Translation":
				case "Lcl Rotation":
				case "Lcl Scaling":
					double x = Convert.ToDouble(arr[0]);
					double y = Convert.ToDouble(arr[1]);
					double z = Convert.ToDouble(arr[2]);
					property = new Property<XYZ>(this.Name, Flags, new XYZ(x, y, z));
					break;
				case "int":
				case "Integer":
				case "Enum":
				case "enum":
					property = new Property<int>(this.Name, Flags, Convert.ToInt32(value));
					break;
				case "KString":
					property = new Property<string>(this.Name, Flags, (string)value);
					break;
				case "Float":
					property = new Property<float>(this.Name, Flags, Convert.ToSingle(value));
					break;
				case "FieldOfView":
				case "FieldOfViewX":
				case "FieldOfViewY":
				case "double":
				case "Number":
					property = new Property<double>(this.Name, Flags, Convert.ToDouble(value));
					break;
				case "KTime":
					property = new Property<TimeSpan>(this.Name, Flags, new TimeSpan(Convert.ToInt64(value)));
					break;
				case "Reference":
				case "Compound":
				case "object":
				default:
					property = new Property(this.Name, Flags, value);
					break;
			}

			return property;
		}

		public FbxNode ToNode()
		{
			//P : ["PropName", "PropType", "Label(?)", "Flags", __values__, …]
			FbxNode p = new FbxNode("P", this.Name, this.FbxType, this.Label, MapPropertyFlags(this.Flags));

			switch (this.Value)
			{
				case string:
				case double:
				case int:
				case long:
				case float:
					p.Properties.Add(this.Value);
					break;
				case Color value:
					if (value.A.HasValue)
					{
						p.Properties.Add(value.R / (double)255);
						p.Properties.Add(value.G / (double)255);
						p.Properties.Add(value.B / (double)255);
						p.Properties.Add(value.A / (double)255);
					}
					else
					{
						p.Properties.Add(value.R / (double)255);
						p.Properties.Add(value.G / (double)255);
						p.Properties.Add(value.B / (double)255);
					}
					break;
				case bool value:
					p.Properties.Add(value ? 1 : 0);
					break;
				case XYZ value:
					p.Properties.AddRange(value.ToEnumerable().Cast<object>());
					break;
				case null:
					break;
				default:
					System.Diagnostics.Debug.Fail($"{Value.GetType().FullName}");
					break;
			}

			return p;
		}

		public object GetFbxValue()
		{
			return GetFbxValue(this.Value, out _, out _);
		}

		public static object GetFbxValue(object pvalue, out string fbxtype, out string label)
		{
			switch (pvalue)
			{
				case string value:
					fbxtype = "KString";
					label = string.Empty;
					return value;
				case Color value:
					if (!value.A.HasValue)
					{
						fbxtype = "ColorRGB";
						label = "Color";

						var arr = new double[]
						{
							value.R / (double)255,
							value.G / (double)255,
							value.B / (double)255,
						};

						return arr;
					}
					else
					{
						fbxtype = "ColorAndAlpha";
						label = string.Empty;

						var arr = new double[]
						{
							value.R / (double)255,
							value.G / (double)255,
							value.B / (double)255,
							value.A.Value / (double)255,
						};

						return arr;
					}
				case double value:
					fbxtype = "double";
					label = "Number";
					return value;
				case byte value:
					fbxtype = "int";
					label = "Integer";
					return (int)value;
				case int value:
					fbxtype = "int";
					label = "Integer";
					return value;
				case long value:
					fbxtype = string.Empty;
					label = string.Empty;
					return value;
				case float value:
					fbxtype = "Float";
					label = string.Empty;
					return value;
				case bool value:
					fbxtype = "bool";
					label = string.Empty;
					return value ? 1 : 0;
				case XYZ value:
					fbxtype = "Vector3D";
					label = "Vector";
					double[] xyz =
					{
						value.X,
						value.Y,
						value.Z
					};
					return xyz;
				default:
					throw new NotImplementedException($"Unknown FbxProperty type : {pvalue.GetType().FullName}");
			}
		}

		public static string MapPropertyFlags(PropertyFlags flags)
		{
			System.Text.StringBuilder str = new System.Text.StringBuilder();

			if ((flags & PropertyFlags.Animatable) != 0)
			{
				str.Append('A');
			}
			if ((flags & PropertyFlags.Animated) != 0)
			{
				str.Append('+');
			}
			if ((flags & PropertyFlags.UserDefined) != 0)
			{
				str.Append('U');
			}
			if ((flags & PropertyFlags.Hidden) != 0)
			{
				str.Append('H');
			}
			return str.ToString();
		}

		public static PropertyFlags ParseFlags(string value)
		{
			PropertyFlags flags = PropertyFlags.None;

			if (string.IsNullOrEmpty(value))
			{
				return PropertyFlags.None;
			}

			int i = 0;
			for (; i < value.Length; i++)
			{
				char c = value[i];
				switch (c)
				{
					case 'A':
						flags |= PropertyFlags.Animatable;
						break;
					case '+':
						flags |= PropertyFlags.Animated;
						break;
					case 'H':
						flags |= PropertyFlags.Hidden;
						break;
					case 'U':
						flags |= PropertyFlags.UserDefined;
						break;
					case 'L':
					case 'N':
						break;
				}
			}
			return flags;
		}
	}
}


FbxPropertyTemplate.cs-------------
using CSMath;
using MeshIO.Entities.Geometries;
using MeshIO.Shaders;
using System;
using System.Collections.Generic;
using System.Linq;

namespace MeshIO.FBX
{
	public class FbxPropertyTemplate
	{
		public string ObjectTypeName { get; }

		public string Name { get; }

		public Dictionary<string, FbxProperty> Properties { get; } = new();

		public FbxPropertyTemplate() : this(string.Empty, string.Empty, []) { }

		public FbxPropertyTemplate(string objectTypeName, string name, Dictionary<string, FbxProperty> properties)
		{
			this.ObjectTypeName = objectTypeName;
			this.Name = name;
			this.Properties = properties;
		}

		public static FbxPropertyTemplate Create(string fbxObjectType)
		{
			switch (fbxObjectType)
			{
				case FbxFileToken.Model:
					return new FbxPropertyTemplate("Model", "FbxNode", getFbxNodeTemplate());
				case FbxFileToken.Geometry:
					return new FbxPropertyTemplate("Geometry", "FbxMesh", getFbxGeometryTemplate());
				case FbxFileToken.Material:
					return new FbxPropertyTemplate("Material", "FbxSurfaceMaterial", getFbxMaterialTemplate());
				default:
					throw new ArgumentException($"Unknown fbx ObjectType name {fbxObjectType}");
			}
		}

		public static FbxPropertyTemplate Create<T>(T element)
			where T : SceneElement
		{
			switch (element)
			{
				case Node:
					return new FbxPropertyTemplate("Model", "FbxNode", getFbxNodeTemplate());
				case Geometry:
					return new FbxPropertyTemplate("Geometry", "FbxMesh", getFbxGeometryTemplate());
				case Material:
					return new FbxPropertyTemplate("Material", "FbxSurfaceMaterial", getFbxMaterialTemplate());
				default:
					throw new ArgumentException();
			}
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="name"></param>
		/// <param name="value"></param>
		/// <param name="fbxProperty"></param>
		/// <returns>True if the property has been updated</returns>
		public bool GetUpdated(string name, object value, out FbxProperty fbxProperty)
		{
			if (this.Properties.TryGetValue(name, out FbxProperty existing)
				&& !value.Equals(existing.Value))
			{
				fbxProperty = new FbxProperty(existing, value);
				return true;
			}
			else
			{
				fbxProperty = null;
				return false;
			}
		}

		private static Dictionary<string, FbxProperty> getFbxNodeTemplate()
		{
			return new List<FbxProperty>
			{
				new FbxProperty("QuaternionInterpolate", "enum", "", PropertyFlags.None, 0) ,
				new FbxProperty("RotationOffset", "Vector3D", "Vector", PropertyFlags.None,XYZ.Zero),
				new FbxProperty("RotationPivot", "Vector3D", "Vector", PropertyFlags.None,XYZ.Zero),
				new FbxProperty("ScalingOffset", "Vector3D", "Vector", PropertyFlags.None,XYZ.Zero),
				new FbxProperty("ScalingPivot", "Vector3D", "Vector", PropertyFlags.None,XYZ.Zero),
				new FbxProperty("TranslationActive", "bool", "", PropertyFlags.None,false),
				new FbxProperty("TranslationMin", "Vector3D", "Vector", PropertyFlags.None,XYZ.Zero),
				new FbxProperty("TranslationMax", "Vector3D", "Vector", PropertyFlags.None,XYZ.Zero),
				new FbxProperty("TranslationMinX", "bool", "", PropertyFlags.None,false),
				new FbxProperty("TranslationMinY", "bool", "", PropertyFlags.None,false),
				new FbxProperty("TranslationMinZ", "bool", "", PropertyFlags.None,false),
				new FbxProperty("TranslationMaxX", "bool", "", PropertyFlags.None,false),
				new FbxProperty("TranslationMaxY", "bool", "", PropertyFlags.None,false),
				new FbxProperty("TranslationMaxZ", "bool", "", PropertyFlags.None,false),
				new FbxProperty("RotationOrder", "enum", "", PropertyFlags.None,0),
				new FbxProperty("RotationSpaceForLimitOnly", "bool", "", PropertyFlags.None,false),
				new FbxProperty("RotationStiffnessX", "double", "Number", PropertyFlags.None,0.0d),
				new FbxProperty("RotationStiffnessY", "double", "Number", PropertyFlags.None,0.0d),
				new FbxProperty("RotationStiffnessZ", "double", "Number", PropertyFlags.None,0.0d),
				new FbxProperty("AxisLen", "double", "Number", PropertyFlags.None,10.0d),
				new FbxProperty("PreRotation", "Vector3D", "Vector", PropertyFlags.None,XYZ.Zero),
				new FbxProperty("PostRotation", "Vector3D", "Vector", PropertyFlags.None,XYZ.Zero),
				new FbxProperty("RotationActive", "bool", "", PropertyFlags.None,false),
				new FbxProperty("RotationMin", "Vector3D", "Vector", PropertyFlags.None,XYZ.Zero),
				new FbxProperty("RotationMax", "Vector3D", "Vector", PropertyFlags.None,XYZ.Zero),
				new FbxProperty("RotationMinX", "bool", "", PropertyFlags.None, false),
				new FbxProperty("RotationMinY", "bool", "", PropertyFlags.None, false),
				new FbxProperty("RotationMinZ", "bool", "", PropertyFlags.None, false),
				new FbxProperty("RotationMaxX", "bool", "", PropertyFlags.None, false),
				new FbxProperty("RotationMaxY", "bool", "", PropertyFlags.None, false),
				new FbxProperty("RotationMaxZ", "bool", "", PropertyFlags.None, false),
				new FbxProperty("InheritType", "enum", "", PropertyFlags.None, 0),
				new FbxProperty("ScalingActive", "bool", "", PropertyFlags.None, 0),
				new FbxProperty("ScalingMin", "Vector3D", "Vector", PropertyFlags.None,XYZ.Zero),
				new FbxProperty("ScalingMax", "Vector3D", "Vector", PropertyFlags.None,new XYZ(1,1,1)),
				new FbxProperty("ScalingMinX", "bool", "", PropertyFlags.None, false),
				new FbxProperty("ScalingMinY", "bool", "", PropertyFlags.None, false),
				new FbxProperty("ScalingMinZ", "bool", "", PropertyFlags.None, false),
				new FbxProperty("ScalingMaxX", "bool", "", PropertyFlags.None, false),
				new FbxProperty("ScalingMaxY", "bool", "", PropertyFlags.None, false),
				new FbxProperty("ScalingMaxZ", "bool", "", PropertyFlags.None, false),
				new FbxProperty("GeometricTranslation", "Vector3D", "Vector", PropertyFlags.None,XYZ.Zero),
				new FbxProperty("GeometricRotation", "Vector3D", "Vector", PropertyFlags.None,XYZ.Zero),
				new FbxProperty("GeometricScaling", "Vector3D", "Vector", PropertyFlags.None,new XYZ(1,1,1)),
				new FbxProperty("MinDampRangeX", "double", "Number", PropertyFlags.None,0.0d),
				new FbxProperty("MinDampRangeY", "double", "Number", PropertyFlags.None,0.0d),
				new FbxProperty("MinDampRangeZ", "double", "Number", PropertyFlags.None,0.0d),
				new FbxProperty("MaxDampRangeX", "double", "Number", PropertyFlags.None,0.0d),
				new FbxProperty("MaxDampRangeY", "double", "Number", PropertyFlags.None,0.0d),
				new FbxProperty("MaxDampRangeZ", "double", "Number", PropertyFlags.None,0.0d),
				new FbxProperty("MinDampStrengthX", "double", "Number", PropertyFlags.None,0.0d),
				new FbxProperty("MinDampStrengthY", "double", "Number", PropertyFlags.None,0.0d),
				new FbxProperty("MinDampStrengthZ", "double", "Number", PropertyFlags.None,0.0d),
				new FbxProperty("MaxDampStrengthX", "double", "Number", PropertyFlags.None,0.0d),
				new FbxProperty("MaxDampStrengthY", "double", "Number", PropertyFlags.None,0.0d),
				new FbxProperty("MaxDampStrengthZ", "double", "Number", PropertyFlags.None,0.0d),
				new FbxProperty("PreferedAngleX", "double", "Number", PropertyFlags.None,0.0d),
				new FbxProperty("PreferedAngleY", "double", "Number", PropertyFlags.None,0.0d),
				new FbxProperty("PreferedAngleZ", "double", "Number", PropertyFlags.None,0.0d),
				new FbxProperty("LookAtProperty", "object", "", PropertyFlags.None,null),
				new FbxProperty("UpVectorProperty", "object", "", PropertyFlags.None ,null),
				new FbxProperty("Show", "bool", "", PropertyFlags.None,true),
				new FbxProperty("NegativePercentShapeSupport", "bool", "", PropertyFlags.None, true),
				new FbxProperty("DefaultAttributeIndex", "int", "Integer", PropertyFlags.None, 0),
				new FbxProperty("Freeze", "bool", "", PropertyFlags.None,false),
				new FbxProperty("LODBox", "bool", "", PropertyFlags.None,false),
				new FbxProperty("Lcl Translation", "Lcl Translation", "", PropertyFlags.Animatable,XYZ.Zero),
				new FbxProperty("Lcl Rotation", "Lcl Rotation", "", PropertyFlags.Animatable,XYZ.Zero),
				new FbxProperty("Lcl Scaling", "Lcl Scaling", "", PropertyFlags.Animatable,new XYZ(1,1,1)),
				new FbxProperty("Visibility", "Visibility", "", PropertyFlags.Animatable,1),
				new FbxProperty("Visibility Inheritance", "Visibility Inheritance", "", PropertyFlags.None,1),
			}.ToDictionary(p => p.Name, p => p);
		}

		private static Dictionary<string, FbxProperty> getFbxGeometryTemplate()
		{
			return new List<FbxProperty>
			{
				new FbxProperty("Color", "ColorRGB", "Color", PropertyFlags.None, new Color(204,204,204)),
				new FbxProperty("BBoxMin", "Vector3D", "Vector", PropertyFlags.None, XYZ.Zero),
				new FbxProperty("BBoxMax", "Vector3D", "Vector", PropertyFlags.None, XYZ.Zero),
				new FbxProperty("Primary Visibility", "bool", "", PropertyFlags.None, true),
				new FbxProperty("Casts Shadows", "bool", "", PropertyFlags.None, true),
				new FbxProperty("Receive Shadows", "bool", "", PropertyFlags.None, true),
			}.ToDictionary(p => p.Name, p => p);
		}

		private static Dictionary<string, FbxProperty> getFbxMaterialTemplate()
		{
			return new List<FbxProperty>
			{
				new FbxProperty("ShadingModel", "KString", "", PropertyFlags.None, "Unknown"),
				new FbxProperty("MultiLayer", "bool", "", PropertyFlags.None, false),
			}.ToDictionary(p => p.Name, p => p);
		}

	}
}

FbxReader.cs-------------
using MeshIO.Core;
using MeshIO.FBX.Readers;
using MeshIO.FBX.Readers.Parsers;
using System;
using System.IO;

namespace MeshIO.FBX
{
	public class FbxReader : ReaderBase
	{
		public FbxReaderOptions Options { get; } = new FbxReaderOptions();

		/// <summary>
		/// Initializes a new instance of the <see cref="FbxReader"/> class for the specified file.
		/// </summary>
		/// <param name="path">The complete file path to read from</param>
		public FbxReader(string path) : base(File.OpenRead(path)) { }

		/// <summary>
		/// Initializes a new instance of the <see cref="FbxReader"/> class for the specified stream.
		/// </summary>
		/// <param name="stream">The stream to read from</param>
		public FbxReader(Stream stream) : base(stream) { }

		/// <summary>
		/// Read a fbx file into an scene
		/// </summary>
		/// <returns></returns>
		public static Scene Read(string path, NotificationEventHandler notificationHandler = null)
		{
			using (FbxReader reader = new FbxReader(path))
			{
				reader.OnNotification += notificationHandler;
				return reader.Read();
			}
		}

		/// <summary>
		/// Read a fbx stream into an scene
		/// </summary>
		/// <returns></returns>
		public static Scene Read(Stream stream, NotificationEventHandler notificationHandler = null)
		{
			using (FbxReader reader = new FbxReader(stream))
			{
				reader.OnNotification += notificationHandler;
				return reader.Read();
			}
		}

		/// <summary>
		/// Parse the FBX file
		/// </summary>
		public FbxRootNode Parse()
		{
			FbxRootNode root;
			using (IFbxParser parser = getParser(this._stream, this.Options))
			{
				root = parser.Parse();
			}

			return root;
		}

		/// <summary>
		/// Read the FBX file
		/// </summary>
		public override Scene Read()
		{
			FbxRootNode root = this.Parse();
			var reader = FbxFileBuilderBase.Create(root, this.Options);
			reader.OnNotification += this.onNotificationEvent;

			return reader.Read();
		}

		private static IFbxParser getParser(Stream stream, FbxReaderOptions options)
		{
			IFbxParser parser = null;
			if (FbxBinary.ReadHeader(stream))
			{
				parser = new FbxBinaryParser(stream, options.ErrorLevel);
			}
			else
			{
				parser = new FbxAsciiParser(stream, options.ErrorLevel);
			}

			return parser;
		}
	}
}


FbxReaderOptions.cs-------------
namespace MeshIO.FBX
{
	public class FbxReaderOptions
	{
		public ErrorLevel ErrorLevel { get; set; } = ErrorLevel.Permissive;
	}
}


FbxRootNode.cs-------------
namespace MeshIO.FBX
{
	/// <summary>
	/// A top-level FBX node
	/// </summary>
	public class FbxRootNode : FbxNodeCollection
	{
		/// <summary>
		/// Describes the format and data of the document
		/// </summary>
		/// <remarks>
		/// It isn't recommended that you change this value directly, because
		/// it won't change any of the document's data which can be version-specific.
		/// Most FBX importers can cope with any version.
		/// </remarks>
		public FbxVersion Version { get; set; } = FbxVersion.v7400;
	}
}


FbxVersion.cs-------------
namespace MeshIO.FBX
{
	/// <summary>
	/// Enumerates the FBX file versions
	/// </summary>
	public enum FbxVersion
	{
		/// <summary>
		/// FBX version 2.0
		/// </summary>
		v2000 = 2000,
		v2001 = 2001,
		/// <summary>
		/// FBX version 3.0
		/// </summary>
		v3000 = 3000,
		v3001 = 3001,
		/// <summary>
		/// FBX version 4.0
		/// </summary>
		v4000 = 4000,
		v4001 = 4001,
		v4050 = 4050,
		/// <summary>
		/// FBX version 5.0
		/// </summary>
		v5000 = 5000,
		/// <summary>
		/// FBX version 5.8
		/// </summary>
		v5800 = 5800,
		/// <summary>
		/// FBX version 6.0
		/// </summary>
		v6000 = 6000,
		/// <summary>
		/// FBX version 6.1
		/// </summary>
		v6100 = 6100,
		/// <summary>
		/// FBX version 7.0
		/// </summary>
		v7000 = 7000,
		/// <summary>
		/// FBX 2011 version
		/// </summary>
		v7100 = 7100,
		/// <summary>
		/// FBX 2012 version
		/// </summary>
		v7200 = 7200,
		/// <summary>
		/// FBX 2013 version
		/// </summary>
		v7300 = 7300,
		/// <summary>
		/// FBX 2014 version
		/// </summary>
		v7400 = 7400,
		/// <summary>
		/// FBX 2016 version, adds large file (>2GB support), not compatible with older versions
		/// </summary>
		v7500 = 7500,
		v7600 = 7600,
		v7700 = 7700
	}
}


FbxWriter.cs-------------
using MeshIO.Core;
using MeshIO.FBX.Writers;
using System;
using System.IO;

namespace MeshIO.FBX
{
	/// <summary>
	/// Implements a <see cref="FbxWriter"/> for writing fbx files.
	/// </summary>
	public class FbxWriter : WriterBase
	{
		/// <summary>
		/// Version to be used in the fbx file
		/// </summary>
		public FbxVersion Version { get { return this.Options.Version; } }

		/// <summary>
		/// Scene to write in the stream
		/// </summary>
		public Scene Scene { get; }

		/// <summary>
		/// Writers fot this writer instance
		/// </summary>
		public FbxWriterOptions Options { get; set; }

		private readonly Stream _stream;

		/// <summary>
		/// Initializes a new instance of the <see cref="FbxWriter"/> class for the specified file.
		/// </summary>
		/// <param name="path">The complete file path to write to.</param>
		/// <param name="scene"></param>
		/// <param name="options"></param>
		public FbxWriter(string path, Scene scene, FbxWriterOptions options = null) : this(File.Create(path), scene, options) { }

		/// <summary>
		/// Initializes a new instance of the <see cref="FbxWriter"/> class for the specified stream.
		/// </summary>
		/// <param name="stream">The stream to write to.</param>
		/// <param name="scene"></param>
		/// <param name="options"></param>
		public FbxWriter(Stream stream, Scene scene, FbxWriterOptions options = null)
		{
			if (stream == null)
				throw new ArgumentNullException(nameof(stream));

			if (!stream.CanSeek)
				throw new ArgumentException("The stream must support seeking. Try reading the data into a buffer first");

			this.Scene = scene;
			this._stream = stream;
			this.Options = options ?? new FbxWriterOptions();
		}

		/// <summary>
		/// Write a <see cref="MeshIO.Scene"/> into a fbx file
		/// </summary>
		/// <param name="path"></param>
		/// <param name="scene"></param>
		/// <param name="options"></param>
		/// <param name="onNotification"></param>
		public static void Write(string path, Scene scene, FbxWriterOptions options = null, NotificationEventHandler onNotification = null)
		{
			using (FbxWriter writer = new FbxWriter(path, scene, options))
			{
				writer.OnNotification += onNotification;
				writer.Write();
			}
		}

		/// <summary>
		/// Write a <see cref="MeshIO.Scene"/> into a stream
		/// </summary>
		/// <param name="stream"></param>
		/// <param name="scene"></param>
		/// <param name="options"></param>
		/// <param name="onNotification"></param>
		public static void Write(Stream stream, Scene scene, FbxWriterOptions options = null, NotificationEventHandler onNotification = null)
		{
			using (FbxWriter writer = new FbxWriter(stream, scene, options))
			{
				writer.OnNotification += onNotification;
				writer.Write();
			}
		}

		/// <summary>
		/// Write a <see cref="MeshIO.Scene"/>
		/// </summary>
		public void Write()
		{
			this.Write(this.Options);
		}

		/// <summary>
		/// Write a <see cref="MeshIO.Scene"/>
		/// </summary>
		/// <param name="options">Options to apply during the write operation</param>
		public void Write(FbxWriterOptions options)
		{
			FbxFileWriterBase fwriter = FbxFileWriterBase.Create(this.Scene, options);

			FbxRootNode n = fwriter.ToNodeStructure();

			using (IFbxWriter sw = FbxWriterFactory.Create(this.Options, n, this._stream))
			{
				sw.Write();
			}
		}

		/// <inheritdoc/>
		public override void Dispose()
		{
			_stream.Dispose();
		}
	}
}

FbxWriterOptions.cs-------------
namespace MeshIO.FBX
{
	public class FbxWriterOptions
	{
		public bool IsBinaryFormat { get; set; } = false;

		public FbxVersion Version { get; set; } = FbxVersion.v7400;

		public FbxGlobalSettings GlobalSettings { get; set; }
	}
}


Connections/FbxConnection.cs-------------
using MeshIO.FBX.Templates;

namespace MeshIO.FBX.Connections
{
	internal class FbxConnection
	{
		public FbxConnectionType ConnectionType { get; }

		public string ParentId { get; }

		public string ChildId { get; }

		public IFbxObjectTemplate Child { get; }

		public IFbxObjectTemplate Parent { get; }

		public FbxConnection(IFbxObjectTemplate child, IFbxObjectTemplate parent)
		{
			Child = child;
			Parent = parent;
		}

		public FbxConnection(FbxConnectionType type, string parentId, string childId)
		{
			ConnectionType = type;
			ParentId = parentId;
			ChildId = childId;
		}

		public string GetComment()
		{
			return $"{Child.FbxObjectName}::{Child.Name}, {Parent.FbxObjectName}::{Parent.Name}";
		}

		public static FbxConnectionType Parse(string type)
		{
			switch (type)
			{
				case "OO":
					return FbxConnectionType.ObjectObject;
				case "OP":
					return FbxConnectionType.ObjectProperty;
				case "PO":
					return FbxConnectionType.PropertyObject;
				case "PP":
					return FbxConnectionType.PropertyProperty;
				default:
					throw new System.ArgumentException($"Unknown Fbx connectin type: {type}", nameof(type));
			}
		}
	}
}


Connections/FbxConnectionType.cs-------------
using CSUtilities.Attributes;

namespace MeshIO.FBX.Connections
{
	internal enum FbxConnectionType
	{
		[StringValue("OO")]
		ObjectObject,
		[StringValue("OP")]
		ObjectProperty,
		[StringValue("PO")]
		PropertyObject,
		[StringValue("PP")]
		PropertyProperty,
	}
}


Exceptions/FbxConverterException.cs-------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MeshIO.FBX.Exceptions
{
	[Serializable]
	public class FbxConverterException : Exception
	{
		public FbxConverterException(string message) : base(message) { }

		public FbxConverterException(string message, Exception inner) : base(message, inner) { }
	}
}


Exceptions/FbxParserException.cs-------------
using System;
using System.Collections.Generic;

namespace MeshIO.FBX.Exceptions
{
	/// <summary>
	/// An error with the FBX data input
	/// </summary>
	public class FbxException : Exception
	{
		/// <summary>
		/// An error at a binary stream offset
		/// </summary>
		/// <param name="position"></param>
		/// <param name="message"></param>
		public FbxException(long position, string message)
			: base($"{message}, near offset {position}") { }

		/// <summary>
		/// An error in a text file
		/// </summary>
		/// <param name="line"></param>
		/// <param name="column"></param>
		/// <param name="message"></param>
		public FbxException(int line, int column, string message)
			: base($"{message}, near line {line} column {column}") { }

		/// <summary>
		/// An error in a node object
		/// </summary>
		/// <param name="nodePath"></param>
		/// <param name="propertyID"></param>
		/// <param name="message"></param>
		public FbxException(Stack<string> nodePath, int propertyID, string message)
			: base(message + ", at " + string.Join("/", nodePath.ToArray()) + (propertyID < 0 ? "" : $"[{propertyID}]")) { }
	}
}


Extensions/Element3DExtensions.cs-------------
using MeshIO.Entities.Geometries;
using System;

namespace MeshIO.FBX.Extensions
{
	internal static class Element3DExtensions
	{
		public static string GetFbxName(this Element3D element)
		{
			switch (element)
			{
				case Node:
					return FbxFileToken.Model;
				case Geometry:
					return FbxFileToken.Geometry;
				default:
					throw new NotImplementedException($"Unknown Element3D : {element.GetType().FullName}");
			}
		}
	}
}


Extensions/LayerElementExtensions.cs-------------
using MeshIO.Entities.Geometries.Layers;
using System;

namespace MeshIO.FBX.Extensions
{
	internal static class LayerElementExtensions
	{
		public static string GetFbxName(this LayerElement layer)
		{
			switch (layer)
			{
				case LayerElementNormal:
					return "LayerElementNormal";
				case LayerElementUV:
					return "LayerElementUV";
				default:
					throw new NotImplementedException($"Unknown LayerElement Type : {layer.GetType().FullName}");
			}
		}

		public static bool TryParseMappingMode(string value, out MappingMode mappingMode)
		{
			switch (value)
			{
				case "ByVertice":
					mappingMode = MappingMode.ByVertex;
					return true;
				case "ByPolygonVertex":
					mappingMode = MappingMode.ByPolygonVertex;
					return true;
				case "ByPolygon":
					mappingMode = MappingMode.ByPolygon;
					return true;
				case "ByEdge":
					mappingMode = MappingMode.ByEdge;
					return true;
				case "AllSame":
					mappingMode = MappingMode.AllSame;
					return true;
				default:
					mappingMode = default;
					return false;
			}
		}

		public static string GetFbxName(this MappingMode mappingMode)
		{
			switch (mappingMode)
			{
				case MappingMode.ByVertex:
					return "ByVertice";
				case MappingMode.ByPolygonVertex:
					return "ByPolygonVertex";
				case MappingMode.ByPolygon:
					return "ByPolygon";
				case MappingMode.ByEdge:
					return "ByEdge";
				case MappingMode.AllSame:
					return "AllSame";
				default:
					throw new ArgumentException($"Unknown MappingMode : {mappingMode}", nameof(mappingMode));
			}
		}

		public static bool TryParseReferenceMode(string value, out ReferenceMode referenceMode)
		{
			switch (value)
			{
				case "Direct":
					referenceMode = ReferenceMode.Direct;
					return true;
				case "Index":
					referenceMode = ReferenceMode.Index;
					return true;
				case "IndexToDirect":
					referenceMode = ReferenceMode.IndexToDirect;
					return true;
				default:
					referenceMode = default;
					return false;
			}
		}

		public static string GetFbxName(this ReferenceMode referenceMode)
		{
			switch (referenceMode)
			{
				case ReferenceMode.Direct:
					return "Direct";
				case ReferenceMode.Index:
					return "Index";
				case ReferenceMode.IndexToDirect:
					return "IndexToDirect";
				default:
					throw new ArgumentException($"Unknown ReferenceMode : {referenceMode}", nameof(referenceMode));
			}
		}
	}
}


obj/Debug/net4.8/.NETFramework,Version=v4.8.AssemblyAttributes.cs-------------
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETFramework,Version=v4.8", FrameworkDisplayName = ".NET Framework 4.8")]


obj/Debug/net4.8/MeshIO.FBX.AssemblyInfo.cs-------------
//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.42000
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DomCr")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyCopyrightAttribute("Copyright (c) 2024 Albert Domenech")]
[assembly: System.Reflection.AssemblyDescriptionAttribute("MeshIO module for fbx format.")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("2.1.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("2.1.0-alpha")]
[assembly: System.Reflection.AssemblyProductAttribute("MeshIO.FBX")]
[assembly: System.Reflection.AssemblyTitleAttribute("MeshIO.FBX")]
[assembly: System.Reflection.AssemblyVersionAttribute("2.1.0.0")]
[assembly: System.Reflection.AssemblyMetadataAttribute("RepositoryUrl", "https://github.com/DomCR/MeshIO")]

// 由 MSBuild WriteCodeFragment 类生成。



obj/Debug/net48/.NETFramework,Version=v4.8.AssemblyAttributes.cs-------------
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETFramework,Version=v4.8", FrameworkDisplayName = ".NET Framework 4.8")]


obj/Debug/net48/MeshIO.FBX.AssemblyInfo.cs-------------
//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.42000
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DomCr")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyCopyrightAttribute("Copyright (c) 2024 Albert Domenech")]
[assembly: System.Reflection.AssemblyDescriptionAttribute("MeshIO module for fbx format.")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("2.1.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("2.1.0-alpha")]
[assembly: System.Reflection.AssemblyProductAttribute("MeshIO.FBX")]
[assembly: System.Reflection.AssemblyTitleAttribute("MeshIO.FBX")]
[assembly: System.Reflection.AssemblyVersionAttribute("2.1.0.0")]
[assembly: System.Reflection.AssemblyMetadataAttribute("RepositoryUrl", "https://github.com/DomCR/MeshIO")]

// 由 MSBuild WriteCodeFragment 类生成。



obj/Debug/net480/.NETFramework,Version=v4.8.AssemblyAttributes.cs-------------
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETFramework,Version=v4.8", FrameworkDisplayName = ".NET Framework 4.8")]


obj/Debug/net480/MeshIO.FBX.AssemblyInfo.cs-------------
//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.42000
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DomCr")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyCopyrightAttribute("Copyright (c) 2024 Albert Domenech")]
[assembly: System.Reflection.AssemblyDescriptionAttribute("MeshIO module for fbx format.")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("2.1.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("2.1.0-alpha")]
[assembly: System.Reflection.AssemblyProductAttribute("MeshIO.FBX")]
[assembly: System.Reflection.AssemblyTitleAttribute("MeshIO.FBX")]
[assembly: System.Reflection.AssemblyVersionAttribute("2.1.0.0")]
[assembly: System.Reflection.AssemblyMetadataAttribute("RepositoryUrl", "https://github.com/DomCR/MeshIO")]

// 由 MSBuild WriteCodeFragment 类生成。



obj/Debug/net5.0/.NETCoreApp,Version=v5.0.AssemblyAttributes.cs-------------
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v5.0", FrameworkDisplayName = ".NET 5.0")]


obj/Debug/net5.0/MeshIO.FBX.AssemblyInfo.cs-------------
//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.42000
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DomCr")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyCopyrightAttribute("Copyright (c) 2024 Albert Domenech")]
[assembly: System.Reflection.AssemblyDescriptionAttribute("MeshIO module for fbx format.")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("2.1.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("2.1.0-alpha")]
[assembly: System.Reflection.AssemblyProductAttribute("MeshIO.FBX")]
[assembly: System.Reflection.AssemblyTitleAttribute("MeshIO.FBX")]
[assembly: System.Reflection.AssemblyVersionAttribute("2.1.0.0")]
[assembly: System.Reflection.AssemblyMetadataAttribute("RepositoryUrl", "https://github.com/DomCR/MeshIO")]

// 由 MSBuild WriteCodeFragment 类生成。



obj/Debug/net6.0/.NETCoreApp,Version=v6.0.AssemblyAttributes.cs-------------
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v6.0", FrameworkDisplayName = ".NET 6.0")]


obj/Debug/net6.0/MeshIO.FBX.AssemblyInfo.cs-------------
//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.42000
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DomCr")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyCopyrightAttribute("Copyright (c) 2024 Albert Domenech")]
[assembly: System.Reflection.AssemblyDescriptionAttribute("MeshIO module for fbx format.")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("2.1.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("2.1.0-alpha")]
[assembly: System.Reflection.AssemblyProductAttribute("MeshIO.FBX")]
[assembly: System.Reflection.AssemblyTitleAttribute("MeshIO.FBX")]
[assembly: System.Reflection.AssemblyVersionAttribute("2.1.0.0")]
[assembly: System.Reflection.AssemblyMetadataAttribute("RepositoryUrl", "https://github.com/DomCR/MeshIO")]

// 由 MSBuild WriteCodeFragment 类生成。



obj/Debug/netstandard2.1/.NETStandard,Version=v2.1.AssemblyAttributes.cs-------------
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETStandard,Version=v2.1", FrameworkDisplayName = ".NET Standard 2.1")]


obj/Debug/netstandard2.1/MeshIO.FBX.AssemblyInfo.cs-------------
//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.42000
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("DomCr")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyCopyrightAttribute("Copyright (c) 2024 Albert Domenech")]
[assembly: System.Reflection.AssemblyDescriptionAttribute("MeshIO module for fbx format.")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("2.1.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("2.1.0-alpha")]
[assembly: System.Reflection.AssemblyProductAttribute("MeshIO.FBX")]
[assembly: System.Reflection.AssemblyTitleAttribute("MeshIO.FBX")]
[assembly: System.Reflection.AssemblyVersionAttribute("2.1.0.0")]
[assembly: System.Reflection.AssemblyMetadataAttribute("RepositoryUrl", "https://github.com/DomCR/MeshIO")]

// 由 MSBuild WriteCodeFragment 类生成。



Readers/FbxFileBuilder7000.cs-------------
namespace MeshIO.FBX.Readers
{
	internal class FbxFileBuilder7000 : FbxFileBuilderBase
	{
		public FbxFileBuilder7000(FbxRootNode root, FbxReaderOptions options) : base(root, options) { }
	}
}


Readers/FbxFileBuilderBase.cs-------------
using MeshIO.Core;
using MeshIO.FBX.Connections;
using MeshIO.FBX.Templates;
using System;
using System.Collections.Generic;

namespace MeshIO.FBX.Readers
{
	internal abstract class FbxFileBuilderBase
	{
		public event NotificationEventHandler OnNotification;

		public FbxVersion Version { get { return this.Root.Version; } }

		public FbxRootNode Root { get; }

		public FbxReaderOptions Options { get; }

		protected readonly Scene _scene;

		protected readonly IFbxObjectTemplate _rootTemplate;

		protected readonly Dictionary<string, FbxPropertyTemplate> _propertyTemplates = new();

		protected readonly Dictionary<string, IFbxObjectTemplate> _objectTemplates = new();

		protected readonly Dictionary<string, List<FbxConnection>> _connections = new();

		protected FbxFileBuilderBase(FbxRootNode root, FbxReaderOptions options)
		{
			this.Root = root;
			this.Options = options;

			this._scene = new Scene();
			this._scene.RootNode.Id = 0;
			this._rootTemplate = new FbxRootNodeTemplate(this._scene.RootNode);
		}

		public static FbxFileBuilderBase Create(FbxRootNode root, FbxReaderOptions options)
		{
			switch (root.Version)
			{
				case FbxVersion.v2000:
				case FbxVersion.v2001:
				case FbxVersion.v3000:
				case FbxVersion.v3001:
				case FbxVersion.v4000:
				case FbxVersion.v4001:
				case FbxVersion.v4050:
				case FbxVersion.v5000:
				case FbxVersion.v5800:
				case FbxVersion.v6000:
				case FbxVersion.v6100:
					throw new NotSupportedException($"Fbx version {root.Version} no supported for reader");
				case FbxVersion.v7000:
				case FbxVersion.v7100:
				case FbxVersion.v7200:
				case FbxVersion.v7300:
				case FbxVersion.v7400:
				case FbxVersion.v7500:
				case FbxVersion.v7600:
				case FbxVersion.v7700:
					return new FbxFileBuilder7000(root, options);
				default:
					throw new NotSupportedException($"Unknown Fbx version {root.Version} for writer");

			}
		}

		public Scene Read()
		{
			foreach (FbxNode n in Root)
			{
				switch (n.Name)
				{
					case FbxFileToken.FBXHeaderExtension:
						this.readHeader(n);
						break;
					case FbxFileToken.GlobalSettings:
						this.readGlobalSettings(n);
						break;
					case FbxFileToken.Documents:
						this.readDocuments(n);
						break;
					case FbxFileToken.References:
						this.readReferences(n);
						break;
					case FbxFileToken.Definitions:
						this.readDefinitions(n);
						break;
					case FbxFileToken.Objects:
						this.readObjects(n);
						break;
					case FbxFileToken.Connections:
						this.readConnections(n);
						break;
					default:
						this.Notify($"Unknown section: {n.Name}", NotificationType.Warning);
						break;
				}
			}

			this.buildScene();

			return this._scene;
		}

		public Dictionary<string, FbxProperty> ReadProperties(FbxNode node)
		{
			Dictionary<string, FbxProperty> properties = new Dictionary<string, FbxProperty>();
			if (!node.TryGetNode(FbxFileToken.GetPropertiesName(this.Version), out FbxNode propertiesNode))
			{
				return properties;
			}

			foreach (FbxNode propNode in propertiesNode)
			{
				FbxProperty prop = this.readFbxProperty(propNode);
				if (prop is null)
					continue;

				properties.Add(prop.Name, prop);
			}

			return properties;
		}

		public bool TryGetTemplate(string id, out IFbxObjectTemplate template)
		{
			return this._objectTemplates.TryGetValue(id, out template);
		}

		public FbxPropertyTemplate GetProperties(string objName)
		{
			if (this._propertyTemplates.TryGetValue(objName, out var properties))
			{
				return properties;
			}
			else
			{
				return new FbxPropertyTemplate();
			}
		}

		public List<FbxConnection> GetChildren(string id)
		{
			if (this._connections.TryGetValue(id, out List<FbxConnection> children))
			{
				return children;
			}
			else
			{
				return new List<FbxConnection>();
			}
		}

		protected FbxProperty readFbxProperty(FbxNode node)
		{
			string name = node.GetProperty<string>(0);
			string type1 = node.GetProperty<string>(1);
			string label = node.GetProperty<string>(2);
			PropertyFlags flags = FbxProperty.ParseFlags(node.GetProperty<string>(3));

			object value = null;

			if(node.Properties.Count == 4)
			{
				value = null;
			}
			else if (node.Properties.Count == 5)
			{
				value = node.Properties[4];
			}
			else
			{
				value = new List<object>();
				for (int i = 4; i < node.Properties.Count; i++)
				{
					(value as List<object>).Add(node.Properties[i]);
				}
			}

			return new FbxProperty(name, type1, label, flags, value);
		}

		protected void buildScene()
		{
			this._rootTemplate.Build(this);
		}

		protected void readHeader(FbxNode node)
		{
			this.Notify("FBXHeaderExtension section not implemented", NotificationType.NotImplemented);

			foreach (FbxNode n in node)
			{
				switch (n.Name)
				{
					default:
						break;
				}
			}
		}

		protected void readGlobalSettings(FbxNode node)
		{
			Dictionary<string, FbxProperty> properties = this.ReadProperties(node);
			FbxPropertyTemplate globalSettings = new FbxPropertyTemplate(FbxFileToken.GlobalSettings, string.Empty, properties);
			this._propertyTemplates.Add(FbxFileToken.GlobalSettings, globalSettings);
		}

		protected void readDocuments(FbxNode node)
		{
			foreach (FbxNode n in node)
			{
				switch (n.Name)
				{
					case FbxFileToken.Count:
						break;
					case FbxFileToken.Document:
						this.readDocument(n);
						break;
					default:
						this.Notify($"{node.Name} | unknown node: {n.Name}", NotificationType.NotImplemented);
						break;
				}
			}
		}

		protected void readDocument(FbxNode node)
		{

		}

		protected void readReferences(FbxNode node)
		{
			if (!node.IsEmpty)
			{
				this.Notify("References section not implemented", NotificationType.NotImplemented);
			}
		}

		protected void readDefinitions(FbxNode node)
		{
			foreach (FbxNode n in node)
			{
				switch (n.Name)
				{
					case FbxFileToken.Count:
					case FbxFileToken.Version:
						break;
					case FbxFileToken.ObjectType:
						this.readDefinition(n);
						break;
					default:
						this.Notify($"{node.Name} | unknown node: {n.Name}", NotificationType.NotImplemented);
						break;
				}
			}
		}

		protected void readDefinition(FbxNode node)
		{
			if (!node.TryGetProperty<string>(0, out string objectType))
			{
				this.Notify($"Undefined ObjectType", NotificationType.Warning);
				return;
			}

			if (objectType == FbxFileToken.GlobalSettings)
			{
				return;
			}

			string name = string.Empty;
			if (!node.TryGetNode("PropertyTemplate", out FbxNode tempalteNode))
			{
				this.Notify($"PropertyTemplate not found for {objectType}", NotificationType.Warning);
				return;
			}

			if (!tempalteNode.TryGetProperty<string>(0, out name))
			{
				this.Notify($"PropertyTemplate name not found for {objectType}", NotificationType.Warning);
				return;
			}

			Dictionary<string, FbxProperty> properties = this.ReadProperties(tempalteNode);
			FbxPropertyTemplate template = new FbxPropertyTemplate(objectType, name, properties);
			this._propertyTemplates.Add(objectType, template);
		}

		protected void readObjects(FbxNode node)
		{
			foreach (FbxNode n in node)
			{
				IFbxObjectTemplate template = null;

				switch (n.Name)
				{
					case FbxFileToken.Model:
						template = new FbxNodeTemplate(n);
						break;
					case FbxFileToken.Geometry:
						template = this.readGeometryNode(n);
						break;
				}

				if (template == null)
				{
					this.Notify($"[{node.Name}] unknown node: {n}", NotificationType.NotImplemented);
					continue;
				}

				if (string.IsNullOrEmpty(template.Id))
				{
					this.Notify($"[{node.Name}] Id not found for node {n}", NotificationType.Warning);
					continue;
				}

				this._objectTemplates.Add(template.Id, template);
			}
		}

		protected IFbxObjectTemplate readGeometryNode(FbxNode node)
		{
			string type = node.GetProperty<string>(2);

			switch (type)
			{
				case FbxFileToken.Mesh:
					return new FbxMeshTemplate(node);
				default:
					return null;
			}
		}

		protected void readConnections(FbxNode node)
		{
			foreach (FbxNode n in node)
			{
				FbxConnection connection;

				FbxConnectionType type = FbxConnection.Parse(n.GetProperty<string>(0));
				string child = n.GetProperty<object>(1).ToString();
				string parent = n.GetProperty<object>(2).ToString();

				connection = new FbxConnection(type, parent, child);

				if (!this._connections.TryGetValue(parent, out List<FbxConnection> children))
				{
					children = new List<FbxConnection>();
					this._connections.Add(parent, children);
				}

				children.Add(connection);
			}
		}

		public void Notify(string message, NotificationType notificationType = NotificationType.Information, Exception ex = null)
		{
			this.OnNotification?.Invoke(this, new NotificationEventArgs(message, notificationType, ex));
		}
	}
}


Readers/Parsers/FbxAsciiParser.cs-------------
using System;
using System.Text;
using System.IO;
using System.Text.RegularExpressions;
using MeshIO.FBX.Exceptions;

namespace MeshIO.FBX.Readers.Parsers
{
    /// <summary>
    /// Reads FBX nodes from a text stream
    /// </summary>
    internal class FbxAsciiParser : IFbxParser
    {
        /// <summary>
        /// The maximum array size that will be allocated
        /// </summary>
        /// <remarks>
        /// If you trust the source, you can expand this value as necessary.
        /// Malformed files could cause large amounts of memory to be allocated
        /// and slow or crash the system as a result.
        /// </remarks>
        public int MaxArrayLength { get; set; } = 1 << 24;
        public bool ApplyArrayLength = false;

        private readonly Stream _stream;
        private readonly ErrorLevel _errorLevel;

        private int _line = 1;
        private int _column = 1;

        /// <summary>
        /// Creates a new reader
        /// </summary>
        /// <param name="stream"></param>
        /// <param name="errorLevel"></param>
        public FbxAsciiParser(Stream stream, ErrorLevel errorLevel = ErrorLevel.Checked)
        {
            if (stream == null)
                throw new ArgumentNullException(nameof(stream));

            _stream = stream;
            _errorLevel = errorLevel;
        }

		/// <inheritdoc/>
		public void Dispose()
		{
			_stream.Dispose();
		}

		// We read bytes a lot, so we should make a more efficient method here
		// (The normal one makes a new byte array each time)

		readonly byte[] singleChar = new byte[1];
        private char? prevChar;
        private bool endStream;
        private bool wasCr;

        // Reads a char, allows peeking and checks for end of stream
        private char readChar()
        {
            if (prevChar != null)
            {
                var c = prevChar.Value;
                prevChar = null;
                return c;
            }
            if (_stream.Read(singleChar, 0, 1) < 1)
            {
                endStream = true;
                return '\0';
            }
            var ch = (char)singleChar[0];
            // Handle line and column numbers here;
            // This isn't terribly accurate, but good enough for diagnostics
            if (ch == '\r')
            {
                wasCr = true;
                _line++;
                _column = 0;
            }
            else
            {
                if (ch == '\n' && !wasCr)
                {
                    _line++;
                    _column = 0;
                }
                wasCr = false;
            }
            _column++;
            return ch;
        }

        // Checks if a character is valid in a real number
        static bool IsDigit(char c, bool first)
        {
            if (char.IsDigit(c))
                return true;
            switch (c)
            {
                case '-':
                case '+':
                    return true;
                case '.':
                case 'e':
                case 'E':
                case 'X':
                case 'x':
                    return !first;
            }
            return false;
        }

        static bool IsLineEnd(char c)
        {
            return c == '\r' || c == '\n';
        }

        // Token to mark the end of the stream
        class EndOfStream
        {
            public override string ToString()
            {
                return "end of stream";
            }
        }

        // Wrapper around a string to mark it as an identifier
        // (as opposed to a string literal)
        class Identifier
        {
            public readonly string String;

            public override bool Equals(object obj)
            {
                var id = obj as Identifier;
                if (id != null)
                    return String == id.String;
                return false;
            }

            public override int GetHashCode()
            {
                return String?.GetHashCode() ?? 0;
            }

            public Identifier(string str)
            {
                String = str;
            }

            public override string ToString()
            {
                return String + ":";
            }
        }

        private object prevTokenSingle;

        // Reads a single token, allows peeking
        // Can return 'null' for a comment or whitespace
        object ReadTokenSingle()
        {
            if (prevTokenSingle != null)
            {
                var ret = prevTokenSingle;
                prevTokenSingle = null;
                return ret;
            }

            var c = readChar();

            if (endStream)
                return new EndOfStream();

            switch (c)
            {
                case ';': // Comments
                    while (!IsLineEnd(readChar()) && !endStream) { } // Skip a line
                    return null;
                case '{': // Operators
                case '}':
                case '*':
                case ':':
                case ',':
                    return c;
                case '"': // String literal
                    var sb1 = new StringBuilder();
                    while ((c = readChar()) != '"')
                    {
                        if (endStream)
                            throw new FbxException(_line, _column,
                                "Unexpected end of stream; expecting end quote");
                        sb1.Append(c);
                    }
                    return sb1.ToString();
                default:
                    if (char.IsWhiteSpace(c))
                    {
                        // Merge whitespace
                        while (char.IsWhiteSpace(c = readChar()) && !endStream) { }
                        if (!endStream)
                            prevChar = c;
                        return null;
                    }
                    if (IsDigit(c, true)) // Number
                    {
                        var sb2 = new StringBuilder();
                        do
                        {
                            sb2.Append(c);
                            c = readChar();
                        } while (IsDigit(c, false) && !endStream);
                        if (!endStream)
                            prevChar = c;
                        var str = sb2.ToString();
                        if (str.Contains("."))
                        {
                            if (str.Split('.', 'e', 'E')[1].Length > 6)
                            {
                                double d;
                                if (!double.TryParse(str, out d))
                                    throw new FbxException(_line, _column,
                                        "Invalid number");
                                return d;
                            }
                            else
                            {
                                float f;
                                if (!float.TryParse(str, out f))
                                    throw new FbxException(_line, _column,
                                        "Invalid number");
                                return f;
                            }
                        }
                        long l;
                        if (!long.TryParse(str, out l))
                            throw new FbxException(_line, _column,
                                "Invalid integer");
                        // Check size and return the smallest possible
                        if (l >= byte.MinValue && l <= byte.MaxValue)
                            return (byte)l;
                        if (l >= int.MinValue && l <= int.MaxValue)
                            return (int)l;
                        return l;
                    }
                    if (char.IsLetter(c) || c == '_') // Identifier
                    {
                        var sb3 = new StringBuilder();
                        do
                        {
                            sb3.Append(c);
                            c = readChar();
                        } while ((char.IsLetterOrDigit(c) || c == '_') && !endStream);
                        if (!endStream)
                            prevChar = c;
                        return new Identifier(sb3.ToString());
                    }
                    break;
            }
            throw new FbxException(_line, _column,
                "Unknown character " + c);
        }

        private object _prevToken;

        // Use a loop rather than recursion to prevent stack overflow
        // Here we can also merge string+colon into an identifier,
        // returning single-character bare strings (for C-type properties)
        object ReadToken()
        {
            object ret;
            if (_prevToken != null)
            {
                ret = _prevToken;
                _prevToken = null;
                return ret;
            }
            do
            {
                ret = ReadTokenSingle();
            } while (ret == null);

            var id = ret as Identifier;

            if (id != null)
            {
                object colon;

                do
                {
                    colon = ReadTokenSingle();
                } while (colon == null);

                if (!':'.Equals(colon))
                {
                    if (id.String.Length > 1)
                        throw new FbxException(_line, _column,
                            "Unexpected '" + colon + "', expected ':' or a single-char literal");

                    ret = id.String[0];
                    prevTokenSingle = colon;
                }
            }
            return ret;
        }

        void ExpectToken(object token)
        {
            var t = ReadToken();
            if (!token.Equals(t))
                throw new FbxException(_line, _column,
                    "Unexpected '" + t + "', expected " + token);
        }

        private enum ArrayType
        {
            Byte = 0,
            Int = 1,
            Long = 2,
            Float = 3,
            Double = 4,
        };

        Array ReadArray()
        {
            // Read array length and header
            var len = ReadToken();
            long l;
            if (len is long)
                l = (long)len;
            else if (len is int)
                l = (int)len;
            else if (len is byte)
                l = (byte)len;
            else
                throw new FbxException(_line, _column,
                    "Unexpected '" + len + "', expected an integer");

            if (l < 0)
                throw new FbxException(_line, _column,
                    "Invalid array length " + l);

            if (l > MaxArrayLength && ApplyArrayLength)
                throw new FbxException(_line, _column,
                    "Array length " + l + " higher than permitted maximum " + MaxArrayLength);

            ExpectToken('{');
            ExpectToken(new Identifier("a"));
            var array = new double[l];

            // Read array elements
            bool expectComma = false;
            object token;
            var arrayType = ArrayType.Byte;
            long pos = 0;
            while (!'}'.Equals(token = ReadToken()))
            {
                if (expectComma)
                {
                    if (!','.Equals(token))
                        throw new FbxException(_line, _column,
                            "Unexpected '" + token + "', expected ','");
                    expectComma = false;
                    continue;
                }
                if (pos >= array.Length)
                {
                    if (_errorLevel >= ErrorLevel.Checked)
                        throw new FbxException(_line, _column,
                            "Too many elements in array");
                    continue;
                }

                // Add element to the array, checking for the maximum
                // size of any one element.
                // (I'm not sure if this is the 'correct' way to do it, but it's the only
                // logical one given the nature of the ASCII format)
                double d;
                if (token is byte)
                {
                    d = (byte)token;
                }
                else if (token is int)
                {
                    d = (int)token;
                    if (arrayType < ArrayType.Int)
                        arrayType = ArrayType.Int;
                }
                else if (token is long)
                {
                    d = (long)token;
                    if (arrayType < ArrayType.Long)
                        arrayType = ArrayType.Long;
                }
                else if (token is float)
                {
                    d = (float)token;
                    // A long can't be accurately represented by a float
                    arrayType = arrayType < ArrayType.Long
                        ? ArrayType.Float : ArrayType.Double;
                }
                else if (token is double)
                {
                    d = (double)token;
                    if (arrayType < ArrayType.Double)
                        arrayType = ArrayType.Double;
                }
                else
                    throw new FbxException(_line, _column,
                            "Unexpected '" + token + "', expected a number");
                array[pos++] = d;
                expectComma = true;
            }
            if (pos < array.Length && _errorLevel >= ErrorLevel.Checked)
                throw new FbxException(_line, _column,
                    "Too few elements in array - expected " + (array.Length - pos) + " more");

            // Convert the array to the smallest type we can see
            Array ret;
            switch (arrayType)
            {
                case ArrayType.Byte:
                    var bArray = new byte[array.Length];
                    for (int i = 0; i < bArray.Length; i++)
                        bArray[i] = (byte)array[i];
                    ret = bArray;
                    break;
                case ArrayType.Int:
                    var iArray = new int[array.Length];
                    for (int i = 0; i < iArray.Length; i++)
                        iArray[i] = (int)array[i];
                    ret = iArray;
                    break;
                case ArrayType.Long:
                    var lArray = new long[array.Length];
                    for (int i = 0; i < lArray.Length; i++)
                        lArray[i] = (long)array[i];
                    ret = lArray;
                    break;
                case ArrayType.Float:
                    var fArray = new float[array.Length];
                    for (int i = 0; i < fArray.Length; i++)
                        fArray[i] = (long)array[i];
                    ret = fArray;
                    break;
                default:
                    ret = array;
                    break;
            }
            return ret;
        }

        /// <summary>
        /// Reads the next node from the stream
        /// </summary>
        /// <returns>The read node, or <c>null</c></returns>
        public FbxNode ReadNode()
        {
            var first = ReadToken();
            var id = first as Identifier;
            if (id == null)
            {
                if (first is EndOfStream)
                    return null;
                throw new FbxException(_line, _column,
                    "Unexpected '" + first + "', expected an identifier");
            }
            var node = new FbxNode { Name = id.String };

            // Read properties
            object token;
            bool expectComma = false;
            while (!'{'.Equals(token = ReadToken()) && !(token is Identifier) && !'}'.Equals(token))
            {
                if (expectComma)
                {
                    if (!','.Equals(token))
                        throw new FbxException(_line, _column,
                            "Unexpected '" + token + "', expected a ','");
                    expectComma = false;
                    continue;
                }
                if (token is char)
                {
                    var c = (char)token;
                    switch (c)
                    {
                        case '*':
                            token = ReadArray();
                            break;
                        case '}':
                        case ':':
                        case ',':
                            throw new FbxException(_line, _column,
                                "Unexpected '" + c + "' in property list");
                    }
                }
                node.Properties.Add(token);
                expectComma = true; // The final comma before the open brace isn't required
            }
            // TODO: Merge property list into an array as necessary
            // Now we're either at an open brace, close brace or a new node
            if (token is Identifier || '}'.Equals(token))
            {
                _prevToken = token;
                return node;
            }
            // The while loop can't end unless we're at an open brace, so we can continue right on
            object endBrace;
            while (!'}'.Equals(endBrace = ReadToken()))
            {
                _prevToken = endBrace; // If it's not an end brace, the next node will need it
                node.Nodes.Add(ReadNode());
            }
            if (node.Nodes.Count < 1) // If there's an open brace, we want that to be preserved
                node.Nodes.Add(null);
            return node;
        }

        /// <summary>
        /// Reads a full document from the stream
        /// </summary>
        /// <returns>The complete document object</returns>
        public FbxRootNode Parse()
        {
            var ret = new FbxRootNode();

            _stream.Position = 0;

            // Read version string
            const string versionString = @"; FBX (\d)\.(\d)\.(\d) project file";
            char c;
            while (char.IsWhiteSpace(c = readChar()) && !endStream) { } // Skip whitespace

            bool hasVersionString = false;

            if (c == ';')
            {
                var sb = new StringBuilder();
                do
                {
                    sb.Append(c);
                } while (!IsLineEnd(c = readChar()) && !endStream);
                var match = Regex.Match(sb.ToString(), versionString);
                hasVersionString = match.Success;
                if (hasVersionString)
                    ret.Version = (FbxVersion)(
                        int.Parse(match.Groups[1].Value) * 1000 +
                        int.Parse(match.Groups[2].Value) * 100 +
                        int.Parse(match.Groups[3].Value) * 10
                    );
            }

            if (!hasVersionString && _errorLevel >= ErrorLevel.Strict)
                throw new FbxException(_line, _column,
                    "Invalid version string; first line must match \"" + versionString + "\"");

            FbxNode node;
            while ((node = ReadNode()) != null)
                ret.Nodes.Add(node);

            return ret;
        }
    }
}


Readers/Parsers/FbxBinaryParser.cs-------------
using System;
using System.Text;
using System.IO;
using System.IO.Compression;
using MeshIO.FBX.Exceptions;

namespace MeshIO.FBX.Readers.Parsers
{
	/// <summary>
	/// Reads FBX nodes from a binary stream
	/// </summary>
	internal class FbxBinaryParser : FbxBinary, IFbxParser
	{
		private delegate object ReadPrimitive(BinaryReader reader);

		private readonly BinaryReader _stream;

		private readonly ErrorLevel _errorLevel;

		/// <summary>
		/// Creates a new reader
		/// </summary>
		/// <param name="stream">The stream to read from</param>
		/// <param name="errorLevel">When to throw an <see cref="FbxException"/></param>
		/// <exception cref="ArgumentException"><paramref name="stream"/> does
		/// not support seeking</exception>
		public FbxBinaryParser(Stream stream, ErrorLevel errorLevel = ErrorLevel.Checked)
		{
			if (stream == null)
				throw new ArgumentNullException(nameof(stream));

			if (!stream.CanSeek)
				throw new ArgumentException("The stream must support seeking. Try reading the data into a buffer first");

			_stream = new BinaryReader(stream, Encoding.ASCII);
			_errorLevel = errorLevel;
		}

		/// <summary>
		/// Reads a single node.
		/// </summary>
		/// <remarks>
		/// This won't read the file header or footer, and as such will fail if the stream is a full FBX file
		/// </remarks>
		/// <returns>The node</returns>
		/// <exception cref="FbxException">The FBX data was malformed
		/// for the reader's error level</exception>
		public FbxNode ReadNode(FbxRootNode document)
		{
			var endOffset = document.Version >= FbxVersion.v7500 ? _stream.ReadInt64() : _stream.ReadInt32();
			var numProperties = document.Version >= FbxVersion.v7500 ? _stream.ReadInt64() : _stream.ReadInt32();
			var propertyListLen = document.Version >= FbxVersion.v7500 ? _stream.ReadInt64() : _stream.ReadInt32();
			var nameLen = _stream.ReadByte();
			var name = nameLen == 0 ? "" : Encoding.ASCII.GetString(_stream.ReadBytes(nameLen));

			if (endOffset == 0)
			{
				// The end offset should only be 0 in a null node
				if (_errorLevel >= ErrorLevel.Checked && (numProperties != 0 || propertyListLen != 0 || !string.IsNullOrEmpty(name)))
					throw new FbxException(_stream.BaseStream.Position,
						"Invalid node; expected NULL record");
				return null;
			}

			var node = new FbxNode { Name = name };

			var propertyEnd = _stream.BaseStream.Position + propertyListLen;
			// Read properties
			for (int i = 0; i < numProperties; i++)
				node.Properties.Add(readProperty());

			if (_errorLevel >= ErrorLevel.Checked && _stream.BaseStream.Position != propertyEnd)
				throw new FbxException(_stream.BaseStream.Position,
					"Too many bytes in property list, end point is " + propertyEnd);

			// Read nested nodes
			var listLen = endOffset - _stream.BaseStream.Position;
			if (_errorLevel >= ErrorLevel.Checked && listLen < 0)
				throw new FbxException(_stream.BaseStream.Position,
					"Node has invalid end point");
			if (listLen > 0)
			{
				FbxNode nested;
				do
				{
					nested = ReadNode(document);
					if (nested != null)
						node.Nodes.Add(nested);
				} while (nested != null);
				if (_errorLevel >= ErrorLevel.Checked && _stream.BaseStream.Position != endOffset)
					throw new FbxException(_stream.BaseStream.Position,
						"Too many bytes in node, end point is " + endOffset);
			}
			return node;
		}

		/// <summary>
		/// Reads an FBX document from the stream
		/// </summary>
		/// <returns>The top-level node</returns>
		/// <exception cref="FbxException">The FBX data was malformed
		/// for the reader's error level</exception>
		public FbxRootNode Parse()
		{
			_stream.BaseStream.Position = 0;

			// Read header
			bool validHeader = ReadHeader(_stream.BaseStream);
			if (_errorLevel >= ErrorLevel.Strict && !validHeader)
				throw new FbxException(_stream.BaseStream.Position,
					"Invalid header string");
			var document = new FbxRootNode { Version = (FbxVersion)_stream.ReadInt32() };

			// Read nodes
			var dataPos = _stream.BaseStream.Position;
			FbxNode nested;
			do
			{
				nested = ReadNode(document);
				if (nested != null)
					document.Nodes.Add(nested);
			} while (nested != null);

			// Read footer code
			var footerCode = new byte[footerCodeSize];
			_stream.BaseStream.Read(footerCode, 0, footerCode.Length);
			if (_errorLevel >= ErrorLevel.Strict)
			{
				var validCode = GenerateFooterCode(document);
				if (!CheckEqual(footerCode, validCode))
					throw new FbxException(_stream.BaseStream.Position - footerCodeSize,
						"Incorrect footer code");
			}

			// Read footer extension
			dataPos = _stream.BaseStream.Position;
			var validFooterExtension = CheckFooter(_stream, document.Version);
			if (_errorLevel >= ErrorLevel.Strict && !validFooterExtension)
				throw new FbxException(dataPos, "Invalid footer");

			return document;
		}

		/// <inheritdoc/>
		public override void Dispose()
		{
			_stream.Dispose();
		}

		// Reads a single property
		private object readProperty()
		{
			var dataType = (char)_stream.ReadByte();
			switch (dataType)
			{
				case 'Y':
					return _stream.ReadInt16();
				case 'C':
					return (char)_stream.ReadByte();
				case 'I':
					return _stream.ReadInt32();
				case 'F':
					return _stream.ReadSingle();
				case 'D':
					return _stream.ReadDouble();
				case 'L':
					return _stream.ReadInt64();
				case 'f':
					return readArray(br => br.ReadSingle(), typeof(float));
				case 'd':
					return readArray(br => br.ReadDouble(), typeof(double));
				case 'l':
					return readArray(br => br.ReadInt64(), typeof(long));
				case 'i':
					return readArray(br => br.ReadInt32(), typeof(int));
				case 'b':
					return readArray(br => br.ReadBoolean(), typeof(bool));
				case 'S':
					var len = _stream.ReadInt32();
					var str = len == 0 ? "" : Encoding.ASCII.GetString(_stream.ReadBytes(len));
					// Convert \0\1 to '::' and reverse the tokens
					if (str.Contains(binarySeparator))
					{
						var tokens = str.Split(new[] { binarySeparator }, StringSplitOptions.None);
						var sb = new StringBuilder();
						bool first = true;
						for (int i = tokens.Length - 1; i >= 0; i--)
						{
							if (!first)
								sb.Append(asciiSeparator);
							sb.Append(tokens[i]);
							first = false;
						}
						str = sb.ToString();
					}
					return str;
				case 'R':
					return _stream.ReadBytes(_stream.ReadInt32());
				default:
					throw new FbxException(_stream.BaseStream.Position - 1,
						"Invalid property data type `" + dataType + "'");
			}
		}

		// Reads an array, decompressing it if required
		private Array readArray(ReadPrimitive readPrimitive, Type arrayType)
		{
			var len = _stream.ReadInt32();
			var encoding = _stream.ReadInt32();
			var compressedLen = _stream.ReadInt32();
			var ret = Array.CreateInstance(arrayType, len);
			var stream = _stream;
			var endPos = _stream.BaseStream.Position + compressedLen;
			if (encoding != 0)
			{
				if (_errorLevel >= ErrorLevel.Checked)
				{
					if (encoding != 1)
						throw new FbxException(_stream.BaseStream.Position - 1,
							"Invalid compression encoding (must be 0 or 1)");
					var cmf = _stream.ReadByte();
					if ((cmf & 0xF) != 8 || cmf >> 4 > 7)
						throw new FbxException(_stream.BaseStream.Position - 1,
							"Invalid compression format " + cmf);
					var flg = _stream.ReadByte();
					if (_errorLevel >= ErrorLevel.Strict && ((cmf << 8) + flg) % 31 != 0)
						throw new FbxException(_stream.BaseStream.Position - 1,
							"Invalid compression FCHECK");
					if ((flg & 1 << 5) != 0)
						throw new FbxException(_stream.BaseStream.Position - 1,
							"Invalid compression flags; dictionary not supported");
				}
				else
				{
					_stream.BaseStream.Position += 2;
				}
				var codec = new DeflateWithChecksum(_stream.BaseStream, CompressionMode.Decompress);
				stream = new BinaryReader(codec);
			}
			try
			{
				for (int i = 0; i < len; i++)
					ret.SetValue(readPrimitive(stream), i);
			}
			catch (InvalidDataException)
			{
				throw new FbxException(_stream.BaseStream.Position - 1,
					"Compressed data was malformed");
			}
			if (encoding != 0)
			{
				if (_errorLevel >= ErrorLevel.Checked)
				{
					_stream.BaseStream.Position = endPos - sizeof(int);
					var checksumBytes = new byte[sizeof(int)];
					_stream.BaseStream.Read(checksumBytes, 0, checksumBytes.Length);

					int checksum = 0;
					for (int i = 0; i < checksumBytes.Length; i++)
					{
						checksum = (checksum << 8) + checksumBytes[i];
					}

#if !NET
					if (checksum != ((DeflateWithChecksum)stream.BaseStream).Checksum)
					{
						throw new FbxException(_stream.BaseStream.Position,
							"Compressed data has invalid checksum");
					}
#endif
				}
				else
				{
					_stream.BaseStream.Position = endPos;
				}
			}
			return ret;
		}
	}
}


Readers/Parsers/IFbxParser.cs-------------
using System;

namespace MeshIO.FBX.Readers.Parsers
{
	internal interface IFbxParser : IDisposable
	{
		FbxRootNode Parse();
	}
}


Templates/FbxConnectionTemplate.cs-------------
namespace MeshIO.FBX.Templates
{
    internal struct FbxConnectionTemplate
    {
        public string ParentId { get; }

        public string ChildId { get; }

        public FbxConnectionTemplate(string parentId, string childId)
        {
            ParentId = parentId;
            ChildId = childId;
        }
    }
}


Templates/FbxGeometryTemplate.cs-------------
#if NETFRAMEWORK
using CSUtilities.Extensions;
#endif
using CSMath;
using MeshIO.Entities.Geometries;
using MeshIO.Entities.Geometries.Layers;
using MeshIO.FBX.Extensions;
using MeshIO.FBX.Readers;
using System;
using System.Collections;
using System.Collections.Generic;

namespace MeshIO.FBX.Templates
{
	internal abstract class FbxGeometryTemplate<T> : FbxObjectTemplate<T>
		where T : Geometry
	{
		public override string FbxObjectName { get { return FbxFileToken.Geometry; } }

		protected FbxGeometryTemplate(T geometry) : base(geometry) { }

		protected FbxGeometryTemplate(FbxNode node, T geometry) : base(node, geometry) { }

		public override void Build(FbxFileBuilderBase builder)
		{
			base.Build(builder);

			readLayers();
		}

		protected override void addProperties(Dictionary<string, FbxProperty> properties)
		{
			if (properties.Remove("Primary Visibility", out FbxProperty isVisible))
			{
				_element.IsVisible = (bool)isVisible.ToProperty().Value;
			}

			if (properties.Remove("Casts Shadows", out FbxProperty castShadows))
			{
				_element.CastShadows = (bool)castShadows.ToProperty().Value;
			}

			if (properties.Remove("Receive Shadows", out FbxProperty receiveShadows))
			{
				_element.ReceiveShadows = (bool)receiveShadows.ToProperty().Value;
			}

			base.addProperties(properties);
		}

		protected void readLayers()
		{
			FbxNode node = FbxNode;
			var geometry = _element;

			if (node.TryGetNode("LayerElementNormal", out FbxNode layerElementNormal))
			{
				geometry.Layers.Add(mapLayerElementNormal(layerElementNormal));
			}

			if (node.TryGetNode("LayerElementBinormal", out FbxNode layerElementBinormal))
			{
				geometry.Layers.Add(mapLayerElementBinormal(layerElementBinormal));
			}

			if (node.TryGetNode("LayerElementTangent", out FbxNode layerElementTangent))
			{
				geometry.Layers.Add(mapLayerElementTangent(layerElementTangent));
			}

			if (node.TryGetNode("LayerElementMaterial", out FbxNode layerElementMaterial))
			{
				geometry.Layers.Add(BuildLayerElementMaterial(layerElementMaterial));
			}

			if (node.TryGetNode("LayerElementUV", out FbxNode layerElementUV))
			{
				geometry.Layers.Add(mapLayerElementUV(layerElementUV));
			}

			if (node.TryGetNode("LayerElementSmoothing", out FbxNode layerElementSmoothing))
			{
				geometry.Layers.Add(mapLayerElementSmoothing(layerElementSmoothing));
			}
		}

		private void mapCommonLayer(LayerElement layer, FbxNode node)
		{
			if (node.TryGetNode("Name", out FbxNode name))
			{
				layer.Name = name.Value as string;
			}

			if (node.TryGetNode("MappingInformationType", out FbxNode mappingInformationType))
			{
				if (LayerElementExtensions.TryParseMappingMode((string)mappingInformationType.Value, out MappingMode mappingMode))
				{
					layer.MappingMode = mappingMode;
				}
			}

			if (node.TryGetNode("ReferenceInformationType", out FbxNode referenceInformationType))
			{
				if (LayerElementExtensions.TryParseReferenceMode((string)referenceInformationType.Value, out ReferenceMode referenceMode))
				{
					layer.ReferenceMode = referenceMode;
				}
			}
		}

		private LayerElement mapLayerElementNormal(FbxNode node)
		{
			LayerElementNormal layer = new LayerElementNormal();

			mapCommonLayer(layer, node);

			if (node.TryGetNode("Normals", out FbxNode normals))
			{
				layer.Normals = arrToXYZ(arrToDoubleArray(normals.Value as IEnumerable));
			}

			if (node.TryGetNode("NormalsW", out FbxNode normalsw))
			{
				layer.Weights.AddRange(arrToDoubleArray(normalsw.Value as IEnumerable));
			}

			return layer;
		}

		private LayerElement mapLayerElementBinormal(FbxNode node)
		{
			LayerElementBinormal layer = new LayerElementBinormal();

			mapCommonLayer(layer, node);

			if (node.TryGetNode("Binormals", out FbxNode normals))
			{
				layer.Normals = arrToXYZ(arrToDoubleArray(normals.Value as IEnumerable));
			}

			if (node.TryGetNode("BinormalsW", out FbxNode normalsw))
			{
				layer.Weights.AddRange(arrToDoubleArray(normalsw.Value as IEnumerable));
			}

			return layer;
		}

		private LayerElement mapLayerElementTangent(FbxNode node)
		{
			LayerElementTangent layer = new LayerElementTangent();

			mapCommonLayer(layer, node);

			if (node.TryGetNode("Tangents", out FbxNode normals))
			{
				layer.Tangents = arrToXYZ(arrToDoubleArray(normals.Value as IEnumerable));
			}

			if (node.TryGetNode("TangentsW", out FbxNode normalsw))
			{
				layer.Weights.AddRange(arrToDoubleArray(normalsw.Value as IEnumerable));
			}

			return layer;
		}

		private LayerElement mapLayerElementUV(FbxNode node)
		{
			LayerElementUV layer = new LayerElementUV();

			mapCommonLayer(layer, node);

			if (node.TryGetNode("UV", out FbxNode uv))
			{
				layer.UV = arrToXY(arrToDoubleArray(uv.Value as IEnumerable));
			}

			if (node.TryGetNode("UVIndex", out FbxNode indices))
			{
				layer.Indexes.AddRange(toArr<int>(indices.Value as IEnumerable));
			}

			return layer;
		}

		private LayerElement mapLayerElementSmoothing(FbxNode node)
		{
			LayerElementSmoothing layer = new LayerElementSmoothing();

			mapCommonLayer(layer, node);

			if (node.TryGetNode("Smoothing", out FbxNode smooth))
			{
				layer.Smoothing.AddRange(toArr<int>(smooth.Value as IEnumerable));
			}

			return layer;
		}

		private LayerElement BuildLayerElementMaterial(FbxNode node)
		{
			LayerElementMaterial layer = new LayerElementMaterial();

			mapCommonLayer(layer, node);

			if (node.TryGetNode("Materials", out FbxNode materials))
			{
				layer.Indexes.AddRange(toArr<int>(materials.Value as IEnumerable));
			}

			return layer;
		}

		protected IEnumerable<T> toArr<T>(IEnumerable arr)
		{
			foreach (var item in arr)
			{
				yield return (T)Convert.ChangeType(item, typeof(T));
			}
		}

		protected double[] arrToDoubleArray(IEnumerable arr)
		{
			List<double> converted = new List<double>();
			foreach (object item in arr)
			{
				converted.Add(Convert.ToDouble(item));
			}

			return converted.ToArray();
		}

		protected List<XY> arrToXY(double[] arr)
		{
			List<XY> xy = new List<XY>();

			//Check for null value
			if (arr == null || arr.Length == 1)
				return xy;

			if (arr.Length % 2 != 0)
				throw new ArgumentOutOfRangeException("2D point array with odd length");

			//Create the vertices
			for (int i = 1; i < arr.Length; i += 2)
			{
				XY v = new XY(arr[i - 1], arr[i]);
				xy.Add(v);
			}

			return xy;
		}

		protected List<XYZ> arrToXYZ(double[] arr)
		{
			List<XYZ> xyz = new List<XYZ>();

			if (arr == null || arr.Length == 1)
				return xyz;

			if (arr.Length % 3 != 0)
				throw new ArgumentOutOfRangeException("3D point array length is not multiple of 3");

			for (int i = 2; i < arr.Length; i += 3)
			{
				XYZ v = new XYZ(arr[i - 2], arr[i - 1], arr[i]);
				xyz.Add(v);
			}

			return xyz;
		}
	}
}


Templates/FbxGlobalSettingsTemplate.cs-------------
using MeshIO.FBX.Readers;
using MeshIO.FBX.Writers;
using System.Collections.Generic;

namespace MeshIO.FBX.Templates
{
	internal class FbxGlobalSettingsTemplate : IFbxObjectTemplate
	{
		public string Id { get; }

		public string Name { get; }

		public string FbxObjectName { get; } = FbxFileToken.GlobalSettings;

		public string FbxTypeName { get; }

		public List<FbxProperty> FbxProperties { get; } = new();

		public FbxGlobalSettingsTemplate()
		{
			FbxProperties.Add(new("UpAxis", "int", "Integer", PropertyFlags.None, 1));
			FbxProperties.Add(new("UpAxisSign", "int", "Integer", PropertyFlags.None, 1));
			FbxProperties.Add(new("FrontAxis", "int", "Integer", PropertyFlags.None, 2));
			FbxProperties.Add(new("FrontAxisSign", "int", "Integer", PropertyFlags.None, 1));
			FbxProperties.Add(new("CoordAxis", "int", "Integer", PropertyFlags.None, 0));
			FbxProperties.Add(new("CoordAxisSign", "int", "Integer", PropertyFlags.None, 1));
			FbxProperties.Add(new("OriginalUpAxis", "int", "Integer", PropertyFlags.None, 2));
			FbxProperties.Add(new("OriginalUpAxisSign", "int", "Integer", PropertyFlags.None, 1));
			FbxProperties.Add(new("UnitScaleFactor", "double", "Number", PropertyFlags.None, 1.0d));
			FbxProperties.Add(new("OriginalUnitScaleFactor", "double", "Number", PropertyFlags.None, 1.0d));
			FbxProperties.Add(new("AmbientColor", "ColorRGB", "Color", PropertyFlags.None, new Color()));
			FbxProperties.Add(new("DefaultCamera", "KString", string.Empty, PropertyFlags.None, "Producer Perspective"));
			FbxProperties.Add(new("TimeMode", "enum", string.Empty, PropertyFlags.None, 6));
			FbxProperties.Add(new("TimeProtocol", "enum", string.Empty, PropertyFlags.None, 2));
			FbxProperties.Add(new("SnapOnFrameMode", "enum", string.Empty, PropertyFlags.None, 0));
			FbxProperties.Add(new("TimeSpanStart", "KTime", "Time", PropertyFlags.None, 0));
			FbxProperties.Add(new("TimeSpanStop", "KTime", "Time", PropertyFlags.None, 153953860000));
			FbxProperties.Add(new("CustomFrameRate", "double", "Number", PropertyFlags.None, -1.0d));
			FbxProperties.Add(new("TimeMarker", "Compound", string.Empty, PropertyFlags.None, string.Empty));
			FbxProperties.Add(new("CurrentTimeMarker", "int", "Integer", PropertyFlags.None, -1));
		}

		public void ProcessChildren(FbxFileWriterBase fbxFileWriterBase)
		{
			throw new System.InvalidOperationException();
		}

		public void ApplyTemplate(FbxPropertyTemplate template)
		{
			throw new System.InvalidOperationException();
		}

		public Element3D GetElement()
		{
			throw new System.InvalidOperationException();
		}

		public void Build(FbxFileBuilderBase builder)
		{
			throw new System.InvalidOperationException();
		}

		public FbxNode ToFbxNode(FbxFileWriterBase writer)
		{
			throw new System.InvalidOperationException();
		}
	}
}


Templates/FbxMeshTemplate.cs-------------
using CSMath;
using MeshIO.Entities.Geometries;
using MeshIO.Entities.Geometries.Layers;
using MeshIO.FBX.Extensions;
using MeshIO.FBX.Readers;
using MeshIO.FBX.Writers;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace MeshIO.FBX.Templates
{
	internal class FbxMeshTemplate : FbxGeometryTemplate<Mesh>
	{
		public override string FbxTypeName { get { return FbxFileToken.Mesh; } }

		public FbxMeshTemplate(Mesh mesh) : base(mesh) { }

		public FbxMeshTemplate(FbxNode node) : base(node, new Mesh())
		{
		}

		public override void Build(FbxFileBuilderBase builder)
		{
			base.Build(builder);

			readPolygons();
			readEdges();
		}

		protected override void addObjectBody(FbxNode node, FbxFileWriterBase writer)
		{
			node.Add("GeometryVersion", 124);

			base.addObjectBody(node, writer);

			if (this._element.Vertices.Any())
			{
				double[] arr = _element.Vertices.SelectMany(x => x.ToEnumerable()).ToArray();
				node.Add("Vertices", arr);
				node.Add("PolygonVertexIndex", polygonsArray(this._element));

				if (this._element.Edges.Any())
				{
					node.Add("Edges", this._element.Edges.ToArray());
				}
			}

			this.writeLayers(node);
		}

		private void writeLayers(FbxNode node)
		{
			List<string> layerNames = new List<string>();

			foreach (LayerElement layer in this._element.Layers)
			{
				node.Nodes.Add(this.writeLayer(layer));

				layerNames.Add(layer.GetFbxName());
			}

			FbxNode layers = node.Add("Layer", 0);
			layers.Add(FbxFileToken.Version, 100);

			foreach (string name in layerNames)
			{
				FbxNode layerElement = layers.Add("LayerElement");

				layerElement.Add("Type", name);
				layerElement.Add("TypedIndex", 0);
			}
		}

		private FbxNode writeLayer<T>(T layer)
			where T : LayerElement
		{
			FbxNode node = new FbxNode(layer.GetFbxName(), 0);
			node.Add(FbxFileToken.Version, 100);
			node.Add("Name", layer.Name);
			node.Add("MappingInformationType", layer.MappingMode.GetFbxName());
			node.Add("ReferenceInformationType", layer.ReferenceMode.GetFbxName());

			string indexesName = string.Empty;
			switch (layer)
			{
				case LayerElementBinormal bnormals:
					node.Add("Binormals", bnormals.Normals.SelectMany(x => x.ToEnumerable()).ToArray());
					node.Add("BinormalsW", bnormals.Weights.ToArray());
					indexesName = "BinormalsIndex";
					break;
				case LayerElementNormal normals:
					node.Add("Normals", normals.Normals.SelectMany(x => x.ToEnumerable()).ToArray());
					node.Add("NormalsW", normals.Weights.ToArray());
					indexesName = "NormalsIndex";
					break;
				case LayerElementMaterial material:
					node.Add("Materials", material.Indexes.ToArray());
					break;
				case LayerElementTangent tangents:
					node.Add("Tangents", tangents.Tangents.SelectMany(x => x.ToEnumerable()).ToArray());
					node.Add("TangentsW", tangents.Weights.ToArray());
					indexesName = "TangentsIndex";
					break;
				case LayerElementUV uv:
					node.Add("UV", uv.UV.SelectMany(x => x.ToEnumerable()).ToArray());
					indexesName = "UVIndex";
					break;
				default:
					break;
			}

			if (layer.ReferenceMode != ReferenceMode.Direct && layer.Indexes.Any() && layer is not LayerElementMaterial)
			{
				node.Add(indexesName, layer.Indexes.ToArray());
			}

			return node;
		}

		private void readEdges()
		{
			if (FbxNode.TryGetNode("Edges", out FbxNode edges))
			{
				_element.Edges.AddRange(toArr<int>(edges.Value as IEnumerable));
			}
		}

		private void readPolygons()
		{
			if (FbxNode.TryGetNode("PolygonVertexIndex", out FbxNode polygons))
			{
				_element.Polygons = mapPolygons(polygons.Value as int[]);
			}
		}

		protected List<Polygon> mapPolygons(int[] arr)
		{
			List<Polygon> polygons = new List<Polygon>();

			if (arr == null)
				return polygons;

			//Check if the arr are faces or quads
			if (arr[2] < 0)
			{
				for (int i = 2; i < arr.Length; i += 3)
				{
					Triangle tmp = new Triangle(
						arr[i - 2],
						arr[i - 1],
						//Substract a unit to the last
						Math.Abs(arr[i]) - 1);

					polygons.Add(tmp);
				}
			}
			//Quads
			else if (arr[3] < 0)
			{
				for (int i = 3; i < arr.Length; i += 4)
				{
					Quad tmp = new Quad(
						Math.Abs(arr[i - 3]),
						Math.Abs(arr[i - 2]),
						Math.Abs(arr[i - 1]),
						//Substract a unit to the last
						Math.Abs(arr[i]) - 1);

					polygons.Add(tmp);
				}
			}

			return polygons;
		}

		protected int[] polygonsArray(Mesh mesh)
		{
			List<int> arr = new List<int>();

			//Check if the polygons list is empty
			if (!mesh.Polygons.Any())
				return arr.ToArray();

			if (mesh.Polygons.First() is Triangle)
			{
				foreach (Triangle t in mesh.Polygons)
				{
					arr.Add((int)t.Index0);
					arr.Add((int)t.Index1);
					arr.Add(-((int)t.Index2 + 1));
				}
			}
			else
			{
				foreach (Quad t in mesh.Polygons)
				{
					arr.Add((int)t.Index0);
					arr.Add((int)t.Index1);
					arr.Add((int)t.Index2);
					arr.Add(-((int)t.Index3 + 1));
				}
			}

			return arr.ToArray();
		}
	}
}


Templates/FbxNodeTemplate.cs-------------
#if NETFRAMEWORK
using CSUtilities.Extensions;
#endif
using CSMath;
using MeshIO.Entities;
using MeshIO.FBX.Connections;
using MeshIO.FBX.Readers;
using MeshIO.FBX.Writers;
using MeshIO.Shaders;
using System.Collections.Generic;
using System.Reflection;

namespace MeshIO.FBX.Templates
{
	internal class FbxNodeTemplate : FbxObjectTemplate<Node>
	{
		public override string FbxObjectName { get { return FbxFileToken.Model; } }

		public override string FbxTypeName { get { return FbxFileToken.Mesh; } }

		public FbxNodeTemplate(FbxNode node) : base(node, new Node())
		{
		}

		public FbxNodeTemplate(Node root) : base(root)
		{
		}

		public override void Build(FbxFileBuilderBase builder)
		{
			base.Build(builder);

			processChildren(builder);
		}

		protected override void addObjectBody(FbxNode node, FbxFileWriterBase writer)
		{
			node.Add(FbxFileToken.Version, 232);

			base.addObjectBody(node, writer);

			node.Add(FbxFileToken.Shading, 'T');
			node.Add(FbxFileToken.CullingOff, "CullingOff");
		}

		public override void ProcessChildren(FbxFileWriterBase fwriter)
		{
			base.ProcessChildren(fwriter);

			foreach (Node node in this._element.Nodes)
			{
				fwriter.CreateConnection(node, this);
			}

			foreach (Shaders.Material mat in this._element.Materials)
			{
				fwriter.CreateConnection(mat, this);
			}

			foreach (Entities.Entity entity in this._element.Entities)
			{
				fwriter.CreateConnection(entity, this);
			}
		}

		protected override void addProperties(Dictionary<string, FbxProperty> properties)
		{
			if (properties.Remove("Lcl Translation", out FbxProperty translation))
			{
				_element.Transform.Translation = (XYZ)translation.ToProperty().Value;
			}

			if (properties.Remove("Lcl Rotation", out FbxProperty rotation))
			{
				_element.Transform.Translation = (XYZ)rotation.ToProperty().Value;
			}

			if (properties.Remove("Lcl Scaling", out FbxProperty scaling))
			{
				_element.Transform.Translation = (XYZ)scaling.ToProperty().Value;
			}

			base.addProperties(properties);
		}

		protected void processChildren(FbxFileBuilderBase builder)
		{
			foreach (FbxConnection c in builder.GetChildren(Id))
			{
				if (!builder.TryGetTemplate(c.ChildId, out IFbxObjectTemplate template))
				{
					builder.Notify($"[{_element.GetType().FullName}] child object not found {c.ChildId}", Core.NotificationType.Warning);
					continue;
				}

				addChild(template.GetElement());

				template.Build(builder);
			}
		}

		protected void addChild(Element3D element)
		{
			switch (element)
			{
				case Node node:
					_element.Nodes.Add(node);
					break;
				case Material mat:
					_element.Materials.Add(mat);
					break;
				case Entity entity:
					_element.Entities.Add(entity);
					break;
				default:
					break;
			}
		}
	}
}


Templates/FbxObjectTemplate.cs-------------
using System;
using System.Collections.Generic;
using System.Diagnostics;
using MeshIO.FBX.Readers;
using MeshIO.FBX.Writers;

namespace MeshIO.FBX.Templates
{
	internal abstract class FbxObjectTemplate<T> : IFbxObjectTemplate
		where T : Element3D
	{
		public string Id { get; }

		public string Name { get { return this._element.Name; } }

		public abstract string FbxObjectName { get; }

		public abstract string FbxTypeName { get; }

		public string Prefix { get { return $"{FbxObjectName}::"; } }

		public Dictionary<string, FbxProperty> FbxInstanceProperties { get; } = new();

		public FbxNode FbxNode { get; }

		protected readonly T _element;

		protected FbxObjectTemplate(T element)
		{
			_element = element;
			Id = element.Id.ToString();
		}

		protected FbxObjectTemplate(FbxNode node, T element) : this(element)
		{
			FbxNode = node;
			Id = node?.GetProperty<object>(0).ToString();
		}

		public Element3D GetElement()
		{
			return _element;
		}

		public FbxNode ToFbxNode(FbxFileWriterBase writer)
		{
			FbxNode n = this.nodeHeader();

			this.addObjectBody(n, writer);

			return n;
		}

		public virtual void Build(FbxFileBuilderBase builder)
		{
			FbxPropertyTemplate template = builder.GetProperties(FbxObjectName);

			_element.Id = Convert.ToUInt64(FbxNode.GetProperty<long>(0));
			_element.Name = removePrefix(FbxNode.GetProperty<string>(1));

			Dictionary<string, FbxProperty> nodeProp = builder.ReadProperties(FbxNode);
			foreach (var t in template.Properties)
			{
				if (nodeProp.ContainsKey(t.Key))
				{
					continue;
				}

				nodeProp.Add(t.Key, t.Value);
			}

			addProperties(nodeProp);
		}

		public virtual void ProcessChildren(FbxFileWriterBase fbxFileWriterBase)
		{
		}

		public virtual void ApplyTemplate(FbxPropertyTemplate template)
		{
			foreach (Property item in this._element.Properties)
			{
				if (template.Properties.TryGetValue(item.Name, out FbxProperty property)
					&& item.Value == property.Value)
				{
					continue;
				}

				this.FbxInstanceProperties.Add(item.Name, FbxProperty.CreateFrom(item));
			}
		}

		protected FbxNode nodeHeader()
		{
			return new FbxNode(this.FbxObjectName, this.getId(), $"{this.FbxObjectName}::{_element.Name}", this.FbxTypeName);
		}

		protected virtual void addObjectBody(FbxNode node, FbxFileWriterBase writer)
		{
			node.Nodes.Add(writer.PropertiesToNode(this.FbxInstanceProperties.Values));
		}

		protected string removePrefix(string fullname)
		{
			if (string.IsNullOrEmpty(fullname))
			{
				return string.Empty;
			}
			else if (fullname.StartsWith(Prefix))
			{
				return fullname.Remove(0, Prefix.Length);
			}

			return fullname;
		}

		protected virtual void addProperties(Dictionary<string, FbxProperty> properties)
		{
			foreach (var prop in properties)
			{
				_element.Properties.Add(prop.Value.ToProperty());
			}
		}

		private long getId()
		{
			if (!_element.Id.HasValue)
			{
				_element.Id = IdUtils.CreateId();
			}

			return Math.Abs((long)_element.Id.Value);
		}
	}
}


Templates/FbxRootNodeTemplate.cs-------------
using MeshIO.FBX.Readers;

namespace MeshIO.FBX.Templates
{
	internal class FbxRootNodeTemplate : FbxNodeTemplate
	{
		public FbxRootNodeTemplate(Node root) : base(root)
		{
		}

		public override void Build(FbxFileBuilderBase builder)
		{
			//TODO: Set properties from GlobalSettings

			processChildren(builder);
		}
	}
}


Templates/FbxTemplateFactory.cs-------------
using System;
using MeshIO.Entities.Geometries;

namespace MeshIO.FBX.Templates
{
	internal static class FbxTemplateFactory
	{
		public static IFbxObjectTemplate Create<T>(T element)
			where T : Element3D
		{
			switch (element)
			{
				case Mesh mesh:
					return new FbxMeshTemplate(mesh);
				case Node node:
					return new FbxNodeTemplate(node);
				default:
					throw new NotImplementedException($"{nameof(IFbxObjectTemplate)} for {element.GetType()}");
			}
		}
	}
}


Templates/IFbxObjectTemplate.cs-------------
using MeshIO.FBX.Readers;
using MeshIO.FBX.Writers;

namespace MeshIO.FBX.Templates
{
	internal interface IFbxObjectTemplate
	{
		string Id { get; }

		string Name { get; }

		string FbxObjectName { get; }

		string FbxTypeName { get; }

		Element3D GetElement();

		void Build(FbxFileBuilderBase builder);
		
		FbxNode ToFbxNode(FbxFileWriterBase writer);

		void ProcessChildren(FbxFileWriterBase fbxFileWriterBase);

		void ApplyTemplate(FbxPropertyTemplate template);
	}
}


Writers/FbxAsciiWriter.cs-------------
using System;
using System.Text;
using System.IO;
using System.Collections.Generic;
using MeshIO.FBX.Exceptions;
using MeshIO.FBX.Writers;

namespace MeshIO.FBX
{
	/// <summary>
	/// Writes an FBX document in a text format
	/// </summary>
	internal class FbxAsciiWriter : IDisposable, IFbxWriter
	{
		public FbxRootNode Root { get; }

		/// <summary>
		/// The maximum line length in characters when outputting arrays
		/// </summary>
		/// <remarks>
		/// Lines might end up being a few characters longer than this, visibly and otherwise,
		/// so don't rely on it as a hard limit in code!
		/// </remarks>
		public int MaxLineLength { get; set; } = 260;

		/// <summary>
		/// If this is active the max line length will not be applied
		/// </summary>
		public bool ApplyLineMaxLength { get; set; }

		private readonly Stack<string> _nodePath = new Stack<string>();
		private readonly Stream _stream;

		/// <summary>
		/// Creates a new reader
		/// </summary>
		/// <param name="root"></param>
		/// <param name="stream"></param>
		public FbxAsciiWriter(FbxRootNode root, Stream stream)
		{
			if (stream == null)
			{
				throw new ArgumentNullException(nameof(stream));
			}

			this.Root = root;
			this._stream = stream;
		}

		/// <summary>
		/// Writes an FBX document to the stream
		/// </summary>
		/// <remarks>
		/// ASCII FBX files have no header or footer, so you can call this multiple times
		/// </remarks>
		public void Write()
		{
			if (this.Root == null)
			{
				throw new ArgumentNullException(nameof(this.Root));
			}

			var sb = new StringBuilder();

			// Write version header (a comment, but required for many importers)
			var vMajor = (int)this.Root.Version / 1000;
			var vMinor = ((int)this.Root.Version % 1000) / 100;
			var vRev = ((int)this.Root.Version % 100) / 10;
			sb.Append($"; FBX {vMajor}.{vMinor}.{vRev} project file\n\n");

			this._nodePath.Clear();
			foreach (var n in this.Root.Nodes)
			{
				if (n == null)
				{
					continue;
				}

				this.buildString(n, sb, this.Root.Version >= FbxVersion.v7100);
				sb.Append('\n');
			}
			var b = Encoding.ASCII.GetBytes(sb.ToString());
			this._stream.Write(b, 0, b.Length);
		}

		/// <inheritdoc/>
		public void Dispose()
		{
			this._stream.Dispose();
		}

		private void buildString(FbxNode node, StringBuilder sb, bool writeArrayLength, int indentLevel = 0)
		{
			this._nodePath.Push(node.Name ?? "");
			int lineStart = sb.Length;
			// Write identifier
			for (int i = 0; i < indentLevel; i++)
			{
				sb.Append('\t');
			}

			sb.Append(node.Name).Append(':');

			// Write properties
			var first = true;
			for (int j = 0; j < node.Properties.Count; j++)
			{
				var p = node.Properties[j];
				if (p == null)
				{
					continue;
				}

				if (!first)
				{
					sb.Append(',');
				}

				sb.Append(' ');
				if (p is string)
				{
					sb.Append('"').Append(p).Append('"');
				}
				else if (p is Array)
				{
					var array = (Array)p;
					var elementType = p.GetType().GetElementType();
					// ReSharper disable once PossibleNullReferenceException
					// We know it's an array, so we don't need to check for null
					if (array.Rank != 1 || !elementType.IsPrimitive)
					{
						throw new FbxException(this._nodePath, j,
							"Invalid array type " + p.GetType());
					}

					if (writeArrayLength)
					{
						sb.Append('*').Append(array.Length).Append(" {\n");
						lineStart = sb.Length;
						for (int i = -1; i < indentLevel; i++)
						{
							sb.Append('\t');
						}

						sb.Append("a: ");
					}
					bool pFirst = true;
					foreach (var v in (Array)p)
					{
						if (!pFirst)
						{
							sb.Append(',');
						}

						var vstr = v.ToString();

						if (this.ApplyLineMaxLength)
						{
							if ((sb.Length - lineStart) + vstr.Length >= this.MaxLineLength)
							{
								sb.Append('\n');
								lineStart = sb.Length;
							}
						}

						sb.Append(vstr);
						pFirst = false;
					}
					if (writeArrayLength)
					{
						sb.Append('\n');
						for (int i = 0; i < indentLevel; i++)
						{
							sb.Append('\t');
						}

						sb.Append('}');
					}
				}
				else if (p is char)
				{
					sb.Append((char)p);
				}
				else if (p.GetType().IsPrimitive && p is IFormattable)
				{
					sb.Append(p);
				}
				else
				{
					throw new FbxException(this._nodePath, j,
						"Invalid property type " + p.GetType());
				}

				first = false;
			}

			// Write child nodes
			if (node.Nodes.Count > 0)
			{
				sb.Append(" {\n");
				foreach (var n in node.Nodes)
				{
					if (n == null)
					{
						continue;
					}

					this.buildString(n, sb, writeArrayLength, indentLevel + 1);
				}
				for (int i = 0; i < indentLevel; i++)
				{
					sb.Append('\t');
				}

				sb.Append('}');
			}
			sb.Append('\n');

			this._nodePath.Pop();
		}
	}
}


Writers/FbxBinaryWriter.cs-------------
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.IO.Compression;
using System.Runtime.InteropServices;
using MeshIO.FBX.Exceptions;
using MeshIO.FBX.Writers;

namespace MeshIO.FBX
{
	/// <summary>
	/// Writes an FBX document to a binary stream
	/// </summary>
	internal class FbxBinaryWriter : FbxBinary, IFbxWriter
	{
		public FbxRootNode Root { get; }

		/// <summary>
		/// The minimum size of an array in bytes before it is compressed
		/// </summary>
		public int CompressionThreshold { get; set; } = 1024;

		private readonly Stream output;
		private readonly MemoryStream memory;
		private readonly BinaryWriter stream;

		private readonly Stack<string> nodePath = new Stack<string>();

		/// <summary>
		/// Creates a new writer
		/// </summary>
		/// <param name="root"></param>
		/// <param name="stream"></param>
		public FbxBinaryWriter(FbxRootNode root, Stream stream)
		{
			if (stream == null)
			{
				throw new ArgumentNullException(nameof(stream));
			}

			this.Root = root;

			this.output = stream;

			// Wrap in a memory stream to guarantee seeking
			this.memory = new MemoryStream();
			this.stream = new BinaryWriter(this.memory, Encoding.ASCII);
		}

		/// <summary>
		/// Writes an FBX file to the output
		/// </summary>
		public void Write()
		{
			this.stream.BaseStream.Position = 0;
			WriteHeader(this.stream.BaseStream);
			this.stream.Write((int)this.Root.Version);
			// TODO: Do we write a top level node or not? Maybe check the version?
			this.nodePath.Clear();
			foreach (var node in this.Root.Nodes)
			{
				this.WriteNode(this.Root, node);
			}

			this.WriteNode(this.Root, null);
			this.stream.Write(GenerateFooterCode(this.Root));
			this.WriteFooter(this.stream, (int)this.Root.Version);
			this.output.Write(this.memory.GetBuffer(), 0, (int)this.memory.Position);
		}

		/// <inheritdoc/>
		public override void Dispose()
		{
			this.stream.Dispose();
			this.memory.Dispose();
			this.output.Dispose();
		}

		private delegate void PropertyWriter(BinaryWriter sw, object obj);

		struct WriterInfo
		{
			public readonly char id;
			public readonly PropertyWriter writer;

			public WriterInfo(char id, PropertyWriter writer)
			{
				this.id = id;
				this.writer = writer;
			}

			public override string ToString()
			{
				return $"{id}:{this.writer.Method}";
			}
		}

		private static readonly Dictionary<Type, WriterInfo> writePropertyActions
			= new Dictionary<Type, WriterInfo>
			{
				//{ typeof(byte), new WriterInfo('I', (sw, obj) => sw.Write((byte)obj)) },
				{ typeof(int),  new WriterInfo('I', (sw, obj) => sw.Write((int)obj)) },
				{ typeof(short),  new WriterInfo('Y', (sw, obj) => sw.Write((short)obj)) },
				{ typeof(long),   new WriterInfo('L', (sw, obj) => sw.Write((long)obj)) },
				//{ typeof(ulong),   new WriterInfo('L', (sw, obj) => sw.Write(Convert.ToInt64(obj))) },
				{ typeof(float),  new WriterInfo('F', (sw, obj) => sw.Write((float)obj)) },
				{ typeof(double), new WriterInfo('D', (sw, obj) => sw.Write((double)obj)) },
				{ typeof(char),   new WriterInfo('C', (sw, obj) => sw.Write((byte)(char)obj)) },
				{ typeof(byte[]), new WriterInfo('R', WriteRaw) },
				{ typeof(string), new WriterInfo('S', WriteString) },
				// null elements indicate arrays - they are checked again with their element type
				{ typeof(int[]),    new WriterInfo('i', null) },
				{ typeof(long[]),   new WriterInfo('l', null) },
				{ typeof(float[]),  new WriterInfo('f', null) },
				{ typeof(double[]), new WriterInfo('d', null) },
				{ typeof(bool[]),   new WriterInfo('b', null) },
			};

		static void WriteRaw(BinaryWriter stream, object obj)
		{
			var bytes = (byte[])obj;
			stream.Write(bytes.Length);
			stream.Write(bytes);
		}

		static void WriteString(BinaryWriter stream, object obj)
		{
			var str = obj.ToString();
			// Replace "::" with \0\1 and reverse the tokens
			if (str.Contains(asciiSeparator))
			{
				var tokens = str.Split(new[] { asciiSeparator }, StringSplitOptions.None);
				var sb = new StringBuilder();
				bool first = true;
				for (int i = tokens.Length - 1; i >= 0; i--)
				{
					if (!first)
					{
						sb.Append(binarySeparator);
					}

					sb.Append(tokens[i]);
					first = false;
				}
				str = sb.ToString();
			}
			var bytes = Encoding.ASCII.GetBytes(str);
			stream.Write(bytes.Length);
			stream.Write(bytes);
		}

		void WriteArray(Array array, Type elementType, PropertyWriter writer)
		{
			this.stream.Write(array.Length);

			var size = array.Length * Marshal.SizeOf(elementType);
			bool compress = size >= this.CompressionThreshold;
			this.stream.Write(compress ? 1 : 0);

			var sw = this.stream;
			DeflateWithChecksum codec = null;

			var compressLengthPos = this.stream.BaseStream.Position;
			this.stream.Write(size); // Placeholder compressed length
			var dataStart = this.stream.BaseStream.Position;
			if (compress)
			{
				this.stream.Write(new byte[] { 0x58, 0x85 }, 0, 2); // Header bytes for DeflateStream settings
				codec = new DeflateWithChecksum(this.stream.BaseStream, CompressionMode.Compress, true);
				sw = new BinaryWriter(codec);
			}
			foreach (var obj in array)
			{
				writer(sw, obj);
			}

			if (compress)
			{
				codec.Close(); // This is important - otherwise bytes can be incorrect
				var checksum = codec.Checksum;
				byte[] bytes =
				{
					(byte)((checksum >> 24) & 0xFF),
					(byte)((checksum >> 16) & 0xFF),
					(byte)((checksum >> 8) & 0xFF),
					(byte)(checksum & 0xFF),
				};
				this.stream.Write(bytes);
			}

			// Now we can write the compressed data length, since we know the size
			if (compress)
			{
				var dataEnd = this.stream.BaseStream.Position;
				this.stream.BaseStream.Position = compressLengthPos;
				this.stream.Write((int)(dataEnd - dataStart));
				this.stream.BaseStream.Position = dataEnd;
			}
		}

		void WriteProperty(object obj, int id)
		{
			if (obj == null)
			{
				return;
			}

			WriterInfo writerInfo;
			if (!writePropertyActions.TryGetValue(obj.GetType(), out writerInfo))
			{
				throw new FbxException(this.nodePath, id,
					"Invalid property type " + obj.GetType());
			}

			this.stream.Write((byte)writerInfo.id);

			if (writerInfo.writer == null) // Array type
			{
				var elementType = obj.GetType().GetElementType();
				this.WriteArray((Array)obj, elementType, writePropertyActions[elementType].writer);
			}
			else
			{
				writerInfo.writer(this.stream, obj);
			}
		}

		// Data for a null node
		static readonly byte[] nullData = new byte[13];
		static readonly byte[] nullData7500 = new byte[25];

		// Writes a single document to the buffer
		void WriteNode(FbxRootNode document, FbxNode node)
		{
			if (node == null)
			{
				var data = document.Version >= FbxVersion.v7500 ? nullData7500 : nullData;
				this.stream.BaseStream.Write(data, 0, data.Length);
			}
			else
			{
				this.nodePath.Push(node.Name ?? "");
				var name = string.IsNullOrEmpty(node.Name) ? null : Encoding.ASCII.GetBytes(node.Name);
				if (name != null && name.Length > byte.MaxValue)
				{
					throw new FbxException(this.stream.BaseStream.Position,
						"Node name is too long");
				}

				// Header
				var endOffsetPos = this.stream.BaseStream.Position;
				long propertyLengthPos;
				if (document.Version >= FbxVersion.v7500)
				{
					this.stream.Write((long)0); // End offset placeholder
					this.stream.Write((long)node.Properties.Count);
					propertyLengthPos = this.stream.BaseStream.Position;
					this.stream.Write((long)0); // Property length placeholder
				}
				else
				{
					this.stream.Write(0); // End offset placeholder
					this.stream.Write(node.Properties.Count);
					propertyLengthPos = this.stream.BaseStream.Position;
					this.stream.Write(0); // Property length placeholder
				}

				this.stream.Write((byte)(name?.Length ?? 0));
				if (name != null)
				{
					this.stream.Write(name);
				}

				// Write properties and length
				var propertyBegin = this.stream.BaseStream.Position;
				for (int i = 0; i < node.Properties.Count; i++)
				{
					this.WriteProperty(node.Properties[i], i);
				}
				var propertyEnd = this.stream.BaseStream.Position;
				this.stream.BaseStream.Position = propertyLengthPos;
				if (document.Version >= FbxVersion.v7500)
				{
					this.stream.Write((long)(propertyEnd - propertyBegin));
				}
				else
				{
					this.stream.Write((int)(propertyEnd - propertyBegin));
				}

				this.stream.BaseStream.Position = propertyEnd;

				// Write child nodes
				if (node.Nodes.Count > 0)
				{
					foreach (var n in node.Nodes)
					{
						if (n == null)
						{
							continue;
						}

						this.WriteNode(document, n);
					}
					this.WriteNode(document, null);
				}

				// Write end offset
				var dataEnd = this.stream.BaseStream.Position;
				this.stream.BaseStream.Position = endOffsetPos;
				if (document.Version >= FbxVersion.v7500)
				{
					this.stream.Write((long)dataEnd);
				}
				else
				{
					this.stream.Write((int)dataEnd);
				}

				this.stream.BaseStream.Position = dataEnd;

				this.nodePath.Pop();
			}
		}


	}
}


Writers/FbxFileWriter7000.cs-------------
namespace MeshIO.FBX.Writers
{
	internal class FbxFileWriter7000 : FbxFileWriterBase
	{
		public FbxFileWriter7000(Scene scene, FbxWriterOptions options) : base(scene, options)
		{
		}
	}
}


Writers/FbxFileWriterBase.cs-------------
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using MeshIO.FBX.Connections;
using MeshIO.FBX.Templates;

namespace MeshIO.FBX.Writers
{
	internal abstract class FbxFileWriterBase
	{
		public FbxVersion Version { get { return this.Options.Version; } }

		public FbxWriterOptions Options { get; }

		public Scene Scene { get; }

		public Node RootNode { get { return this.Scene.RootNode; } }

		protected readonly Dictionary<string, FbxPropertyTemplate> _tempaltes = new();

		protected readonly Dictionary<string, List<IFbxObjectTemplate>> _definedObjects = new();

		protected readonly Dictionary<ulong, IFbxObjectTemplate> _objectTemplates = new();

		protected readonly List<FbxConnection> _connections = new();

		private readonly FbxRootNode fbxRoot;

		private readonly string MeshIOVersion;

		protected FbxFileWriterBase(Scene scene, FbxWriterOptions options)
		{
			this.Scene = scene;
			this.Options = options;

			this.fbxRoot = new FbxRootNode
			{
				Version = this.Options.Version
			};

			this.MeshIOVersion = Assembly.GetExecutingAssembly().GetName().Version.ToString();
		}

		public static FbxFileWriterBase Create(Scene scene, FbxWriterOptions options)
		{
			FbxVersion version = options.Version;
			switch (version)
			{
				case FbxVersion.v2000:
				case FbxVersion.v2001:
				case FbxVersion.v3000:
				case FbxVersion.v3001:
				case FbxVersion.v4000:
				case FbxVersion.v4001:
				case FbxVersion.v4050:
				case FbxVersion.v5000:
				case FbxVersion.v5800:
				case FbxVersion.v6000:
				case FbxVersion.v6100:
					throw new NotSupportedException($"Fbx version {version} no supported for writer");
				case FbxVersion.v7000:
				case FbxVersion.v7100:
				case FbxVersion.v7200:
				case FbxVersion.v7300:
				case FbxVersion.v7400:
				case FbxVersion.v7500:
				case FbxVersion.v7600:
				case FbxVersion.v7700:
					return new FbxFileWriter7000(scene, options);
				default:
					throw new NotSupportedException($"Unknown Fbx version {version} for writer");

			}
		}

		public FbxRootNode ToNodeStructure()
		{
			this.initializeRoot();

			this.fbxRoot.Nodes.Add(this.nodeFBXHeaderExtension());

			if (this.Options.IsBinaryFormat)
			{
				byte[] id = new byte[16];
				Random random = new Random();
				random.NextBytes(id);
				this.fbxRoot.Add("FileId", id);

				this.fbxRoot.Add("CreationTime", DateTime.Now.ToString("yyyy-MM-dd hh:mm:ss:fff", CultureInfo.InvariantCulture));

				this.fbxRoot.Add("Creator", $"MeshIO.FBX {this.MeshIOVersion}");
			}

			this.fbxRoot.Nodes.Add(this.nodeGlobalSettings());
			this.fbxRoot.Nodes.Add(this.nodeDocuments());
			this.fbxRoot.Nodes.Add(this.nodeReferences());
			this.fbxRoot.Nodes.Add(this.nodeDefinitions());
			this.fbxRoot.Nodes.Add(this.nodeObjects());
			this.fbxRoot.Nodes.Add(this.nodeConnections());

			return this.fbxRoot;
		}

		public bool TryGetPropertyTemplate(string fbxName, out FbxPropertyTemplate template)
		{
			return this._tempaltes.TryGetValue(fbxName, out template);
		}

		public void CreateConnection(Element3D child, IFbxObjectTemplate parent)
		{
			IFbxObjectTemplate objwriter = FbxTemplateFactory.Create(child);
			if (objwriter is null)
			{
				return;
			}

			FbxConnection conn = new FbxConnection(objwriter, parent);

			this._connections.Add(conn);

			objwriter.ProcessChildren(this);

			this._objectTemplates.Add(child.Id.Value, objwriter);
			if (!this._definedObjects.TryGetValue(objwriter.FbxObjectName, out List<IFbxObjectTemplate> lst))
			{
				this._definedObjects.Add(objwriter.FbxObjectName, lst = new List<IFbxObjectTemplate>());
			}
			lst.Add(objwriter);
		}

		protected void initializeRoot()
		{
			//Root node should be processed to create the connections but it is not writen in the file
			this.RootNode.Id = 0;

			IFbxObjectTemplate root = FbxTemplateFactory.Create(this.RootNode);

			root.ProcessChildren(this);
		}


		private FbxNode nodeFBXHeaderExtension()
		{
			FbxNode header = new FbxNode(FbxFileToken.FBXHeaderExtension);

			header.Nodes.Add(new FbxNode(FbxFileToken.FBXHeaderVersion, 1003));
			header.Nodes.Add(new FbxNode("FBXVersion", (int)this.Version));

			if (this.Options.IsBinaryFormat)
			{
				header.Add("EncryptionType", 0);
			}

			DateTime now = DateTime.Now;
			FbxNode tiemespan = new FbxNode(FbxFileToken.CreationTimeStamp);
			tiemespan.Nodes.Add(new FbxNode(FbxFileToken.Version, 1000));
			tiemespan.Nodes.Add(new FbxNode(nameof(now.Year), now.Year));
			tiemespan.Nodes.Add(new FbxNode(nameof(now.Month), now.Month));
			tiemespan.Nodes.Add(new FbxNode(nameof(now.Day), now.Day));
			tiemespan.Nodes.Add(new FbxNode(nameof(now.Hour), now.Hour));
			tiemespan.Nodes.Add(new FbxNode(nameof(now.Minute), now.Minute));
			tiemespan.Nodes.Add(new FbxNode(nameof(now.Second), now.Second));
			tiemespan.Nodes.Add(new FbxNode(nameof(now.Millisecond), now.Millisecond));
			header.Nodes.Add(tiemespan);

			header.Add(FbxFileToken.Creator, $"MeshIO.FBX {this.MeshIOVersion}");

			return header;

			throw new NotImplementedException();
		}

		private FbxNode nodeGlobalSettings()
		{
			FbxGlobalSettingsTemplate globalSettings = new FbxGlobalSettingsTemplate();

			FbxNode settings = new FbxNode(FbxFileToken.GlobalSettings);

			settings.Nodes.Add(new FbxNode(FbxFileToken.Version, 100));

			settings.Nodes.Add(this.PropertiesToNode(globalSettings.FbxProperties));

			this._definedObjects.Add(FbxFileToken.GlobalSettings, new List<IFbxObjectTemplate> { globalSettings });

			return settings;
		}

		private FbxNode nodeDocuments()
		{
			FbxNode documents = new FbxNode(FbxFileToken.Documents);

			documents.Nodes.Add(new FbxNode(FbxFileToken.Count, this.Scene.SubScenes.Count + 1));

			var doc = documents.Add(FbxFileToken.Document, this.Scene.GetIdOrDefault(), this.Scene.Name, FbxFileToken.Scene);
			doc.Add(FbxFileToken.RootNode, Convert.ToInt64(this.RootNode.Id));

			return documents;
		}

		private FbxNode nodeReferences()
		{
			FbxNode references = new FbxNode(FbxFileToken.References);

			references.Nodes.Add(null);

			return references;
		}

		private FbxNode nodeDefinitions()
		{
			FbxNode definitions = new FbxNode(FbxFileToken.Definitions);

			definitions.Nodes.Add(new FbxNode(FbxFileToken.Version, 100));
			definitions.Nodes.Add(new FbxNode(FbxFileToken.Count, this._definedObjects.Sum(o => o.Value.Count)));

			foreach (var item in this._definedObjects)
			{
				FbxNode d = new FbxNode(FbxFileToken.ObjectType, item.Key);
				d.Nodes.Add(new FbxNode(FbxFileToken.Count, item.Value.Count));

				if (item.Key == FbxFileToken.GlobalSettings)
				{
					definitions.Nodes.Add(d);
					continue;
				}

				FbxPropertyTemplate template = FbxPropertyTemplate.Create(item.Key);

				this._tempaltes.Add(item.Key, template);

				var t = new FbxNode("PropertyTemplate", template.Name);
				t.Nodes.Add(this.PropertiesToNode(template.Properties.Values));

				d.Nodes.Add(t);

				definitions.Nodes.Add(d);
			}

			return definitions;
		}

		private FbxNode nodeObjects()
		{
			FbxNode objects = new FbxNode(FbxFileToken.Objects);

			foreach (IFbxObjectTemplate obj in this._objectTemplates.Values)
			{
				if (!this._tempaltes.TryGetValue(obj.FbxObjectName, out FbxPropertyTemplate template))
				{
					template = new FbxPropertyTemplate();
				}

				obj.ApplyTemplate(template);

				objects.Nodes.Add(obj.ToFbxNode(this));
			}

			return objects;
		}

		private FbxNode nodeConnections()
		{
			FbxNode connections = new FbxNode(FbxFileToken.Connections);

			foreach (FbxConnection c in this._connections)
			{
				FbxNode con = connections.Add("C");

				switch (c.ConnectionType)
				{
					case FbxConnectionType.ObjectObject:
						con.Properties.Add("OO");
						break;
					default:
						throw new NotImplementedException();
				}

				con.Properties.Add(long.Parse(c.Child.Id));
				con.Properties.Add(long.Parse(c.Parent.Id));
			}

			return connections;
		}

		public FbxNode PropertiesToNode(IEnumerable<Property> properties)
		{
			if (!properties.Any())
			{
				return null;
			}

			FbxNode node = new FbxNode(FbxFileToken.GetPropertiesName(this.Version));

			foreach (Property p in properties)
			{
				if (p is not FbxProperty fbxProp)
				{
					fbxProp = FbxProperty.CreateFrom(p);
				}

				node.Nodes.Add(fbxProp.ToNode());
			}

			return node;
		}
	}
}


Writers/IFbxWriter.cs-------------
using System;
using System.IO;

namespace MeshIO.FBX.Writers
{
	internal interface IFbxWriter : IDisposable
	{
		void Write();
	}

	internal static class FbxWriterFactory
	{
		public static IFbxWriter Create(FbxWriterOptions options, FbxRootNode root, Stream stream)
		{
			if (options.IsBinaryFormat)
			{
				return new FbxBinaryWriter(root, stream);
			}
			else
			{
				return new FbxAsciiWriter(root, stream);
			}
		}
	}
}


